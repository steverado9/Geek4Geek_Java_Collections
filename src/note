    Java Collection Tutorial
Java Collection Framework holds all the collection classes and interfaces.
The Collection interface (java.util.Collection) and Map interface (java.util.Map).
are the two main “root” interfaces of Java collection classes.
    What is a Framework?
A framework is a set of classes and interfaces which provide a ready-made architecture.
-Collection: A group of individual objects that represent a single entity is known as a collection.
-Collection Framework: To represent a group of objects as a single entity in the Java programming
language we need classes and interfaces defined by the Collection Framework.
-Collection Interface: It is the blueprint of the collection class.
-Collections Class: It is present in java.util package and is a member of Collection Framework.
    Advantages of the collections framework
1) Reduces the programming effort as the programmer does not have to worry about designing the Collection class.
On the same hand java being object-oriented language advances in achieving "abstraction".
Abstraction in Java is the process of hiding internal implementation details and showing only essential functionality to the user.
It focuses on what an object does rather than how it does it.
2)Increases program speed and quality as the programmer now is not worried about thinking best implementation for a specific data structure.
3)The API that implements these interfaces are now having common sets of methods be it of any interfaces such as Collection, Set, List, and Map.

Note: All these collections can be imported using:
import java.util.*;

However, single classes can also be imported by replacing * with the class name
import java.util.ArrayList;
import java.util.LinkedList;

The utility package, "java.util" contains all the classes and interfaces that are required by the collection framework.
The collection framework contains an interface named an "iterable interface" which provides the iterator to iterate through all the collections.

    Iterable interface
is the root interface for the entire collection framework.
The main functionality of this interface is to provide an iterator for the collections.

    The following 6 interfaces are described below
    Collection Interface
contains all the basic methods which every collection has
like adding the data into the collection, removing the data, clearing the data, etc
All these methods are implemented in this interface because these methods are implemented by all the
classes irrespective of their style of implementation.
    List Interface
It is a child interface of the collection interface.
It deals with the arrays and lists types of operations like ArrayList, LinkedList, Vector, and Stack.
    1)ArrayList
provides us with dynamic arrays in Java
The size of an ArrayList is increased automatically if the collection grows or shrinks.
    Key Features
-Resizable Array: ArrayList can automatically grow dynamically in size.
-Indexed Access: ArrayList elements can be accessed using indices like arrays.
-Supports Generics: It ensures type safety at compile-time.
-Not Synchronized: ArrayList uses Collections.synchronizedList() for thread safety.
-Allows Null and Duplicates: ArrayList allows both null values and duplicate elements.
-Maintains Insertion Order: Elements are stored in the order they are added.
    Constructors of ArrayList in Java
In order to Create an ArrayList, we need to create an object of the ArrayList class.
The ArrayList class consists of various constructors which allow the possible creation of the array list.
1. ArrayList(): This constructor is used to build an empty array list.
    ArrayList<Integer> arr = new ArrayList<>();
2. ArrayList(Collection c): This constructor is used to build an array list initialized
with the elements from the collection c.
    ArrayList<String> arr = new ArrayList<>(collection);
3. ArrayList(int capacity): This constructor is used to build an array list with the initial capacity being specified.
    ArrayList<Double> arr = new ArrayList<>(20);
    ArrayList methods
1) add() :  is used to add elements to the list.
There are two versions of the ArrayList add() method i.e.
one without specifying an index
and another with a specified index.
2)There are 3 ways to remove an element from ArrayList
-Using remove() method by indexes(default)
-Using remove() method by values
-Using remove() method over iterators
when using iterators,
-next is used to get the current element
-while hasNext is used to check if there is a current element
3)set() Method:  is used to replace an element at a specified position with a new value.
This is very useful when we need to update an existing element in an ArrayList while maintaining the list's structure.
    Syntax of ArrayList set() Method
set(int index, E element)
-index: Index of the element to replace.
-element: Element to be stored at the specified position.
Returns Value: It returns the element that was previously at the specified position.
4) How to Remove Duplicates from ArrayList in Java
-Using Iterator
step1: Get the ArrayList with duplicate values.
step2: Create another ArrayList.
step3: Traverse through the first arraylist and store the first appearance of each element into the second arraylist using contains() method.
step4: The second ArrayList contains the elements with duplicates removed.
-using LinkedHashSet
A better way  is to remove duplicates from an ArrayList is to convert it into a Set that does not allow duplicates.
Hence LinkedHashSet is the best option available as this do not allows duplicates as well it preserves the insertion order.
-Using Java 8 Stream.distinct()
You can use the distinct() method from the Stream API
The distinct() method return a new Stream without duplicates elements based on the result returned by equals() method,
which can be used for further processing .
 The actual processing of Stream pipeline starts only after calling terminal methods like forEach() or collect().
5)How to reverse an ArrayList
-a). By writing our own function()
    logic 1
reverseArrayList() method in RevArrayList class contains logic for reversing an arraylist with integer objects.
This method takes an arraylist as a parameter, traverses in reverse order and adds all the elements to the newly created arraylist.
Finally the reversed arraylist is returned.
    logic 2
- Run the loop for n/2 times where 'n' is the number of elements in the arraylist.
- In the first pass, Swap the first and nth element
-In the second pass, Swap the second and (n-1)th element and so on till you reach the mid of the arraylist.
-Return the arraylist after the loop termination.
-b). By using Collections class:
Collections is a class in java.util package which contains various static methods for searching, sorting, reversing, finding max, min....etc
We can make use of the In-built Collections.reverse() method for reversing an arraylist.
It takes a list as an input parameter and returns the reversed list.
-c)Reversing an arraylist of user defined objects
The arraylist is reversed using In-built reverse() method of Collections class.
-d)Using ListIterator

6)Convertng ArrayList to String Array
ArrayList class is derived from the List interface.
Here we are given an ArrayList of strings and the task is to convert the ArrayList to a string array.
Methods:
    Using get() method of ArrayList class
-Get the ArrayList of Strings.
-Find the size of ArrayList using size() method, and Create a String Array of this size.
-Fetch each element of the ArrayList one by one using get() method.
-Assigned each element into String Array using assignment(=) operator.
-Printing string array.
    Using toArray() method of ArrayList class
Here we will be creating an object array to store elements received from ArrayList by creating an array of strings.
-Get the ArrayList of String.
-Convert ArrayList to Object array using toArray() method.
-Iterate and convert each element to the desired type using typecasting.
-Here it is converted to String type and added to the string array.
-Print the string array
    Using copyOf() method of Arrays class
-Get the ArrayList of String
-Convert ArrayList to Object array using toArray() method.
-Convert it to String Array using Arrays.copyOf() method.
-Print String Array.

7)Getting a sub-list from an ArrayList
The subList() method of the ArrayList class in Java is used to retrieve a portion of an ArrayList between specified indices.
When we perform any modifications to the sub list, that will reflect in the original list and vice versa.
    Syntax of ArrayList subList() Method
public List<E> subList(int fromIndex, int toIndex);
    Parameters:
fromIndex: Starting index (inclusive) of the sublist.
toIndex: Ending index (exclusive) of the sublist.
Returns Value: It returns a view of the portion of this list between the specified indices.
    Exception: This method throws the following Exceptions.
-IndexOutOfBoundsException: If an endpoint index value is out of range (fromIndex > size).
-IllegalArgumentException: If an endpoint indices are out of order (fromIndex > toIndex).

    2)LinkedList
Linked List is a part of the Collection framework present in java.util package.
This class is an implementation of the LinkedList data structure,
which is a linear data structure where the elements are
linked using pointers and addresses, and each element is known as a node.
This class is an implementation of a doubly-linked list data structure.
Note: The nodes cannot be accessed directly instead we have to start from the head and follow the
link until we find the node that we want.
    Internal Working of LinkedList
The size of the list automatically increases when we dynamically add and remove items.
Internally, the LinkedList is implemented using the doubly linked list data structure.
-Doubly linked list:
Each node in a Doubly Linked List contains the data it holds,
a pointer to the next node in the list, and a pointer to the previous node in the list.
We can traverse the list in both directions (forward and backward), which is a key feature of a Doubly Linked List.
    Constructors in the LinkedList
In order to create a LinkedList, we need to create an object of the LinkedList class.
The LinkedList class consists of various constructors that allow the possible creation of the list.
1)LinkedList(): This constructor is used to create an empty linked list.
2) LinkedList(Collection C): This constructor is used to create an ordered list that contains all the elements of a specified collection,
as returned by the collection's iterator.
    Methods for Java LinkedList
1)add(index, element): This method inserts the specified element at the specified position in the list.
2)add(element): This method Appends the specified element to the end of the list.
3)addAll(index, Collection<E>): This method Inserts all of the elements in the specified collection into this list,
starting at the specified position.
4)addAll(Collection<E>): This method Appends all of the elements in the specified collection to the end of this list,
in the order that they are returned by the specified collection's iterator.
5)addFirst(Element): This method Inserts the specified element at the beginning of this list.
6)addLast(Element): This method Appends the specified element to the end of this list.
7)clear(): This method removes all of the elements from this list.\
8)clone(): This method returns a shallow copy of this LinkedList.
9)contains(Object o): This method returns true if this list contains the specified element.
10)descendingIterator(): This method returns an iterator over the elements in this deque in reverse sequential order.
11)element(): This method retrieves but does not remove, the head (first element) of this list.
12)get(int index): This method returns the element at the specified position in this list.
13)getFirst(): This method returns the first element in this list.
14)getLast(): This method returns the last element in this list.
15)indexOf(Object o): This method returns the index of the first occurrence of the specified element in this list,
or -1 if this list does not contain the element.
16)lastIndexOf(Object o): This method returns the index of the last occurrence of the specified element in this list,
or -1 if this list does not contain the element.
17)listIterator(int index): This method returns a list-iterator of the elements in this list (in proper sequence),
starting at the specified position in the list.
18)offer(E e): This method Adds the specified element as the tail (last element) of this list.
19)offerFirst(E e): This method Inserts the specified element at the front of this list.
20)offerLast(E e): This method Inserts the specified element at the end of this list.
21)peek(): This method retrieves but does not remove, the head (first element) of this list.
22)peekFirst(): This method retrieves, but does not remove, the first element of this list, or returns null if this list is empty.
23)peekLast(): This method retrieves, but does not remove, the last element of this list, or returns null if this list is empty.
24)poll(): This method retrieves and removes the head (first element) of this list.
25)pollFirst(): This method retrieves and removes the first element of this list, or returns null if this list is empty.
26)pollLast(): This method retrieves and removes the last element of this list, or returns null if this list is empty.
27)pop(): This method Pops an element from the stack represented by this list.
28)push(E e): This method pushes an element onto the stack represented by this list.
29)remove(): This method retrieves and removes the head (first element) of this list.
30)remove(int index): This method removes the element at the specified position in this list.
31)remove(Object o): This method removes the first occurrence of the specified element from this list if it is present.
32)removeFirst(): This method removes and returns the first element from this list.
33)removeFirstOccurrence(Object o): This method removes the first occurrence of the specified element in this list
(when traversing the list from head to tail).
34)removeLast(): This method removes and returns the last element from this list.
35)removeLastOccurrence(Object o): This method removes the last occurrence of the specified element in this list
(when traversing the list from head to tail).
36)set(int index, E element): This method replaces the element at the specified position in this list with the specified element.
37)size(): This method returns the number of elements in this list.
38)spliterator(): This method creates a late-binding and fail-fast Spliterator over the elements in this list.
39)toArray(): This method returns an array containing all of the elements in this list in proper sequence (from first to last element).
40)toArray(T[] a): This method returns an array containing all of the elements in this list in proper sequence
(from first to last element); the runtime type of the returned array is that of the specified array.
41)toString(): This method returns a string containing all of the elements in this list in proper sequence (from first to the last element),
each element is separated by commas and the String is enclosed in square brackets.
    The classes that implement the list interface.
-AbstractList: This class is used to implement an unmodifiable list,
for which one needs to only extend this AbstractList Class and implement only the get() and the size() methods.
-CopyOnWriteArrayList: This class implements the list interface.
It is an enhanced version of ArrayList in which all the modifications(add, set, remove, etc.) are implemented by making a fresh copy of the list.
    Accessing elements of a linked list
In Java, the get() method of LinkedList is used to fetch or retrieve an element at a specific index from a LinkedList.
    Check if the LinkedList contains the Element
In Java, the contains() method of LinkedList is used to check whether an element is present in a LinkedList or not.
It takes the element as a parameter and returns True if the element is present in the list.
    Remove All Elements from a LinkedList
In Java, the clear() is used to remove all the elements from a LinkedList.
This method only clears all the element from the list and not deletes the list.
After calling this method, the list will be empty.
    Iterate over LinkedList using Iterator
In Java, the listIterator() method of the LinkedList class returns
a ListIterator that allows us to iterate over the elements of the list.
Now there are two versions of listIterator() method i.e. without index and with an index.
1. listIterator() Method with No Parameters
It creates an ListIterator that starts form the beginning of the list.
2. listIterator() Method with an Index
The listIterator(int index) method creates a ListIterator that starts iterating from the specified index in the list.

    3)Vector
Vector is a resizable array in Java, found in the java.util package.
It is part of the Collection Framework and works like an ArrayList,
but it is synchronized,
meaning it is safe to use in multi-threaded programs.
However, this makes it a bit slower than ArrayList.
   Key Features of Vector
-It expands as elements are added.
-The Vector class is synchronized in nature means it is thread-safe by default.
-Like an ArrayList, it maintains insertion order.
-It allows duplicates and nulls.
-It implements List, RandomAccess, Cloneable and Serializable.
    Vector Capacity in Java
When a Vector is created using the default constructor, it is initialized with a default capacity of 10.
This means it can hold up to 10 elements before needing to grow in size.
If the number of elements exceeds the current capacity, the Vector automatically increases its capacity.
    Formula to calculate new capacity
newCapacity = oldCapacity * 2
    Constructors of Vector
1. Vector(): Creates a default vector of the initial capacity is 10.
    Vector<E> v = new Vector<E>();
2. Vector(int size): Creates a vector whose initial capacity is specified by size.
    Vector<E> v = new Vector<E>(int size);
3. Vector(int size, int incr):  Creates a vector whose initial capacity is specified by size and increment is specified by incr.
It specifies the number of elements to allocate each time a vector is resized upward.
4. Vector(Collection c): Creates a vector that contains the elements of collection c.
Note:
-If the vector increment is not specified then it’s capacity will be doubled in every increment cycle.
-The capacity of a vector cannot be below the size, it may equal to it.
1) adding elements in a vector
To add the elements to the Vector, we use the add() method.
-add(Object): This method is used to add an element at the end of the Vector.
-add(int index, Object): This method is used to add an element at a specific index in the Vector.
2) Updating Elements
To update an element in a Vector, use the set() method.
It takes the index and the new element to replace the existing one at that position.
3) Removing Elements
To remove an element from a Vector, we can use the remove() method.
They are:
-remove(Object): This method is used to remove an object from the Vector.
If there are multiple such objects, then the first occurrence of the object is removed.
-remove(int index): This method takes an integer value which simply removes the element present at that specific index in the Vector.
After removing the element, all the elements are moved to the left to fill the space and the indices of the objects are updated.
4) Iterating the Vector
The most famous ways are by using the basic for loop in combination with a get() method to get the element at
a specific index and the advanced for loop.
    Vector vs ArrayList in Java
ArrayList and Vectors both implement the List interface,
and both use (dynamically resizable) arrays for their internal data structure.
      ArrayList	                        Vector
1) ArrayList is not synchronized.       Vector is synchronized.
2) ArrayList increments 50% of the      Vector increments 100% means doubles the array size
    current array size if the number    if the total number of elements exceeds its capacity.
 of elements exceeds its capacity.
3)ArrayList is not a legacy class.      Vector is a legacy class.
4)ArrayList is fast because             Vector is slow because it is synchronized.
it is non-synchronized.
5)ArrayList uses the Iterator           A Vector can use the Iterator interface or
interface to traverse the elements      Enumeration interface to traverse the elements.
6)ArrayList performance is high         Vector performance is low.
7)Multiple threads is allowed           only one threads are allowed.
    Significant Differences between ArrayList and Vector
Synchronization:
Vector is synchronized, which means only one thread at a time can access the code.
while ArrayList is not synchronized, which means multiple threads can work on ArrayList at the same time.
    Disadvantages of using Vector in Java
1)The synchronization in Vector can lead to slower performance compared to other collection classes, such as ArrayList.
2)If you don't need the synchronization features of Vector, using it will add unnecessary overhead to your code.
    Methods in Vector Class
1)add(E e): Appends the specified element to the end of this Vector.
2)add(int index, E element): Inserts the specified element at the specified position in this Vector.
3)addAll(Collection<?extends E> c): Appends all elements from the given collection to the end of this Vector.
4)addAll(int index,Collection<? extends E> c): Insert all of the elements in the specified Collection into this
Vector at the specified position.
5)addElement(E obj): Adds the specified element to the end, increasing size by one.
6)capacity(): Returns the current capacity of this vector.
7)clear(): Removes all of the elements from this Vector.
8)clone(): Returns a clone of this vector.
9)contains(Object o): Returns true if this vector contains the specified element.
10)containsAll(Collection<?> c): Returns true if this Vector contains all of the elements in the specified Collection.
11)copyInto(Object[] anArray): Copies the components of this vector into the specified array.
12)elementAt(int index): Returns the component at the specified index.
13)elements(): Returns an enumeration of the components of this vector.
14)ensureCapacity(int minCapacity): Increases capacity to ensure it can hold at least the specified number of elements.
15)equals(Object o): Compares the specified Object with this Vector for equality.
16)firstElement(): Returns the first component (the item at index 0) of this vector.
17)forEach(Consumer<?super E> action): Performs the given action for each element of the Iterable until all elements
have been processed or the action throws an exception.
18)get(int index): Returns the element at the specified position in this Vector.
19)hashCode(): Returns the hash code value for this Vector.
20)indexOf(Object o): Returns index of the first occurrence of the element or -1 if not found.
21)indexOf(Object o, int index): Returns index of the first occurrence starting from the given index.
22)insertElementAt(E obj, int index): Inserts the specified object as a component in this vector at the specified index.
23)isEmpty(): Tests if this vector has no components.
24)iterator(): Returns an iterator over the elements in this list in a proper sequence.
25)lastElement(): Returns the last component of the vector.
26)lastIndexOf(Object o): Returns the index of the last occurrence of the element or -1 if not found.
27)lastIndexOf(Object o, int index): Returns index of the last occurrence before the given index.
28)listIterator(): Returns a list iterator over the elements in this list (in proper sequence).
29)listIterator(int index): Returns a list iterator over the elements in this list (in proper sequence),
starting at the specified position in the list.
30)remove(int index): Removes the element at the specified position in this Vector.
31)remove(Object o): Removes the first occurrence of the specified element.
32)removeAll(Collection<?> c): Removes from this Vector all of its elements contained in the specified Collection.
33)removeAllElements(): Removes all components from this vector and sets its size to zero.
34)removeElement(Object obj): Removes the first (lowest-indexed) occurrence of the argument from this vector.
35)removeElementAt(int index): Deletes the component at the specified index.
36)removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that satisfy the given predicate.
37)removeRange(int fromIndex,int toIndex): Removes from this list all of the elements whose index is between fromIndex,
inclusive and toIndex, exclusive.
38)replaceAll(UnaryOperator<E> operator): Replaces each element of this list with the result of applying the operator to that element.
39)retainAll(Collection<?> c): Retains only the elements in this Vector contained in the specified Collection.
40)set(int index, E element): Replaces the element at the specified position in this Vector with the specified element.
41)setElementAt(E obj, int index): Sets the component at the specified index of this vector to be the specified object.
42)setSize(int newSize): Sets the size of this vector.
43)size(): Returns the number of components in this vector.
44)sort(Comparator<? super E> c): Sorts this list according to the order induced by the specified Comparator.
45)spliterator(): Creates a late-binding and fail-fast Spliterator over the elements in this list.
46)subList(int fromIndex, int toIndex): Returns a view of the portion of this List between fromIndex,
inclusive and toIndex, exclusive.
47)toArray(): Returns an array containing all of the elements in this Vector in the correct order.
48)toArray(T[] a): Returns an array containing all the elements.
49)toString(): Returns a string representation of this Vector, containing the String representation of each element.
50)trimToSize(): Trims the capacity of this vector to be the vector's current size.
     Vector provides us with dynamic arrays in Java.
This is a legacy class. It is a thread-safe class.
This is not recommended being used in a single-threaded environment as it might cause extra overheads.
However, to overcome this in Vectors place one can readily use ArrayList.
A single-threaded environment is one where a program can only execute one task at a time.
    How to check if a vector is empty
The Java.util.Vector.isEmpty() method in Java is used to check and verify if a Vector is empty or not.
It returns True if the Vector is empty else it returns False.
    How to Iterate the Vector Elements in the Reverse Order in Java
We will be using two methods:
1)Using For Loop
2)Using ListIterator
The ListIterator method takes the starting index from where traversal has to begin and returns the ListIterator.
ListIterator has methods to traversal forward as well as backward.
We will pass starting index as equal to the size of the array, and then we will use the hasPrevious() method of ListIterator,
in which we will print the backward element to the current index if exists.
    How to copy one java Vector to Another Vector in java
Previously vector was a part of legacy classes but now it is part of Collections.
It also implements a List interface, so we can use any method of list interface on vectors also.
    Ways To copy elements of one vector to another:
1)Passing in the constructor
-In this approach, we will simply pass the one Vector into the other Vector's constructor.
-By using this approach if we change in first vector values then it will not change the values of the second vector.
This is the easiest way of duplicating the vector values.
2)Adding one by one using add() method
-In this approach, we will iterate over each element of  Vector and add that element in the second Vector.
-Here if you change the first Vector element then it will not change the elements of the second Vector.
-It is not the best approach but it's a simple iteration process.
    How to Find the Minimum or Maximum Element from the Vector in Java?
Methods:
1)Using Collection.min() and Collection.max() methods.
Collections package offers a static method of finding the minimum and maximum in a collection.
These methods are Collections.max() and Collections.min().
-Collections.max() finds the maximum element
-Collections.min() finds the minimum element in a collection.
2)Using Iterating over vector elements setting min-max.
-Take a variable say minNumber, and initialized to the maximum value later on to compare and update.
-Take a variable say maxNumber, and initialized to minimum value later on to compare an update.
-Iterate through Vector and compare each element with the above two-variable -
 minNumber
 maxNumber
 -If the number is less than minNumber, update the value of minNumber.
 -If the number is greater than maxNumber, update the value of maxNumber.

    4)Stack
This class is based on the basic principle of last-in-first-out.
This is a legacy class.
This inherits from a Vector class.
It is also a thread-safe class.
This is not recommended being used in a single-threaded environment as it might cause extra overheads.
However, to overcome this in Vectors place one can readily use ArrayDeque.
-ArrayDeque: ArrayDeque is a resizable array implementation of the Deque interface.
which stands for double-ended queue.
-It allows elements to be added or removed from both ends efficiently.
-It can be used as a stack (LIFO) or a queue (FIFO).
-Operations like addFirst(), addLast(), removeFirst(), removeLast() are all done in constant time O(1).
-The ArrayDeque class implements these two interfaces Queue interface and Deque interface.
support concurrent access by multiple threads.
In Java, a Stack is a linear data structure that follows the Last In First Out (LIFO) principle.
and is defined in the java.util package
Internally, it extends the Vector class.
    Key Characteristics of Vector
-Maintains insertion order
-Allows duplicate and null values
-Grows dynamically when capacity is exceeded
-Implements List, RandomAccess, Cloneable and Serializable interfaces.
-Inherits from the AbstractList class
    How to Create a Stack?
In order to create a stack, we must import java.util.stack package
and use the Stack() constructor of this class.
    Performing Different Operations on Stack Class
1. Adding Elements: With the help of push() method we can add element to the stack.
The push() method place the element at the top of the stack.
lifo- last element to enter a stack is the first element to be removed from a stack
2. Accessing the Element: With the help of peek() method we can fetch the top element of the stack.
3. Removing Elements: With the help of pop() method we can delete and return the top element from the stack.
    Prioritize Use of Deque over Stack
The Stack class in Java is inherits from Vector in Java.
It is a thread-safe class.
It is recommended to use ArrayDeque for stack implementation as it is more efficient in a single-threaded environment.
    Methods in Stack Class
1)empty(): This method returns true if nothing is on the top of the stack. Else, returns false.
2)peek(): This method returns the element on the top of the stack, but does not remove it.
3)pop(): This method removes and returns the top element of the stack.
4)push(Object element): This method pushes an element on the top of the stack.
5)search(Object element): This method is used to determine whether an object exists in the stack.
If the element is found,It returns the position of the element from the top of the stack. Else, it returns -1.
    Methods Inherited from the Vector Class
1)add(Object obj): This method is used to appends the specified element to the end of the Vector.
2)add(int index, Object obj): This method is used to inserts the specified element at the specified position in the Vector.
3)addAll(Collection c): This method is used to appends all of the elements in the specified Collection to the end of the Vector,
in the order that they are returned by the specified Collection's Iterator.
4)addAll(int index, Collection c): This method is used to inserts all the elements in the specified Collection into this Vector at the specified position.
5)addElement(Object o): This method is used to adds the specified component to the end of the vector.
6)capacity(): This method returns the current capacity of the vector.
7)clear(): This method removes all the elements from the Vector.
8)clone(): This method returns a clone of the vector.
9)contains(Object o): This method returns true if this vector contains the specified element.
10)containsAll(Collection c): This method returns true if this Vector contains all the elements in the specified Collection.
11)copyInto(Object []array): This method is used to copy the components of this vector into the specified array.
12)elementAt(int index): This method returns the component at the specified index.
13)elements(): This method returns an enumeration of the components of the vector.
14)ensureCapacity(int minCapacity): This method increases the capacity of the vector,
if necessary, to ensure that it can hold at least the number of components specified by the minimum capacity argument.
15)equals(): This method compares the specified Object with the Vector for equality.
16)firstElement(): This method returns the first component (the item at index 0) of the vector.
17)get(int index): This method returns the element at the specified position in the Vector.
18)hashCode(): This method returns the hash code value for the Vector.
19)indexOf(Object o): This method returns the index of the first occurrence of the specified element
in this vector or -1 if this vector does not contain the element.
20)indexOf(Object o, int index): This method returns the index of the first occurrence of the specified element in this vector,
searching forwards from the index or returns -1 if the element is not found.
21)insertElementAt(Object o, int index): This method inserts the specified object as a component in this vector
at the specified index.
22)isEmpty(): This method tests if this vector has no components.
23)iterator(): This method returns an iterator over the elements in this list in proper sequence.
24)lastElement(): This method returns the last component of the vector.
25)lastIndexOf(Object o): This method returns the index of the last occurrence of the specified element
in this vector or -1 If this vector does not contain the element.
26)lastIndexOf(Object o, int index): This method returns the index of the last occurrence of the specified element in this vector,
searching backward from the index or returns -1 if the element is not found.
27)listIterator(): This method returns a list iterator over the elements in this list (in proper sequence).
28)listIterator(int index): This method returns a list iterator over the elements in this list (in proper sequence),
starting at the specified position in the list.
29)remove(int index): This method removes the element at the specified position in this Vector.
30)remove(Object o): This method removes the first occurrence of the specified element in this Vector
If the Vector does not contain the element, it is unchanged.
31)removeAll(Collection c): This method removes from this Vector all of its elements that are contained in the specified Collection.
32)removeAllElements(): This method removes all components from this vector and sets its size to zero.
33)removeElement(Object o): This method removes the first (lowest-indexed) occurrence of the argument from this vector.
34)removeElementAt(int index): This method deletes the component at the specified index.
35)removeRange(int fromIndex, int toIndex): This method removes from this list all the elements whose index is between
fromIndex, inclusive, and toIndex, exclusive.
36)retainAll(Collection c): This method retains only the elements in this Vector that are contained in the specified Collection.
37)set(int index, Object o): This method replaces the element at the specified position in this Vector with the specified element.
38)setElementAt(Object o, int index): This method sets the component at the specified index of this vector to be the specified object.
39)setSize(int newSize): This method sets the size of this vector.
40)size(): This method returns the number of components in this vector.
41)subList(int fromIndex, int toIndex): This method returns a view of the portion of this List between fromIndex,
inclusive, and toIndex, exclusive.
42)toArray(): This method returns an array containing all of the elements in this Vector in the correct order.
43)toArray(Object []array): This method returns an array containing all of the elements in this Vector in the
correct order; the runtime type of the returned array is that of the specified array.
44)toString(): This method returns a string representation of this Vector, containing the String representation of each element.
45)trimToSize(): This method trims the capacity of this vector to be the vector's current size.
    How to check if a stack is empty
The java.util.Stack.empty() method in Java is used to check whether a stack is empty or not.
The method is of boolean type and returns true if the stack is empty else false.
    How to Search Element in Stacks
The java.util.Stack.search(Object element) method in Java is used to search for an element in the stack and get its distance from the top.
This method starts the count of the position from 1 and not from 0.
The element that is on the top of the stack is considered to be at position 1.
The method returns its position if the element is successfully found and returns -1 if the element is absent.
Parameters: The method accepts one parameter element which refers to the element that is required to be searched for in the Stack.

    5)Abstract List
The AbstractList class in Java is a part of the Java Collection Framework.
It implements the Collection interface and the AbstractCollection class.
"AbstractCollection":  This is an unmodifiable collection.
AbstractList class provides a skeletal implementation of the List interface,
to minimize the effort required to implement this interface.
Note: For sequential access data (such as a linked list),
"AbstractSequentialList" should be used in preference to this class.
    Constructor: protected AbstractList()
This is the default constructor, but being protected, it doesn't allow to create an AbstractList object.
    Methods in AbstractList
1)add(int index, E element): Inserts the specified element at the specified position in this list (optional operation).
2)add(E e):Appends the specified element to the end of this list (optional operation).
3)addAll(int index, Collection<? extends E> c): Inserts all of the elements in the specified collection
into this list at the specified position (optional operation).
4)clear(): Removes all of the elements from this list (optional operation).
5)equals(Object o): Compares the specified object with this list for equality.
6)get(int index): Returns the element at the specified position in this list.
7)hashCode(): Returns the hash code value for this list.
8)indexOf(Object o): Returns the index of the first occurrence of the specified element in this list,
or -1 if this list does not contain the element.
9) iterator(): Returns an iterator over the elements in this list in proper sequence.
10)lastIndexOf(Object o): Returns the index of the last occurrence of the specified element in this list,
or -1 if this list does not contain the element.
11)listIterator(): Returns a list iterator over the elements in this list (in proper sequence).
12)listIterator(int index): Returns a list iterator over the elements in this list (in proper sequence),
starting at the specified position in the list.
13)remove(int index): Removes the element at the specified position in this list (optional operation).
14) removeRange(int fromIndex, int toIndex): Removes from this list all of the elements whose index is between
fromIndex, inclusive, and toIndex, exclusive.
15) set(int index, E element): Replaces the element at the specified position in this list with the
specified element (optional operation)
16) subList(int fromIndex, int toIndex): Returns a view of the portion of this list between the specified fromIndex,
inclusive, and toIndex, exclusive.
    Methods declared in class java.util.AbstractCollection
1)addAll(Collection<? extends E> c): Adds all of the elements in the specified collection to this
collection (optional operation).
2)contains(Object o): Returns true if this collection contains the specified element.
3)containsAll(Collection<?> c): Returns true if this collection contains all of the elements in the specified collection.
4)isEmpty(): Returns true if this collection contains no elements.
5) remove(Object o): Removes a single instance of the specified element from this collection, if it is present (optional operation).
7)removeAll(Collection<?> c): Removes all of this collection's elements that are also contained in the specified
collection (optional operation).
8) retainAll(Collection<?> c): Retains only the elements in this collection that are contained in the specified
collection (optional operation).
9) toArray(): Returns an array containing all of the elements in this collection.
10)toArray(T[] a): Returns an array containing all of the elements in this collection; the runtime type of the returned
array is that of the specified array.
11) toString(): Returns a string representation of this collection.
    Methods declared in interface java.util.Collection
1)parallelStream(): Returns a possibly parallel Stream with this collection as its source.
2)removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that
satisfy the given predicate.
3)stream(): Returns a sequential Stream with this collection as its source.
4)toArray(IntFunction<T[]> generator): Returns an array containing all of the elements in this collection, using the
provided generator function to allocate the returned array.
    Methods declared in interface java.util.List
1)addAll(Collection<? extends E> c): Appends all of the elements in the specified collection to the end of this list,
in the order that they are returned by the specified collection's iterator (optional operation).
2)contains(Object o): Returns true if this list contains the specified element.
3) containsAll(Collection<?> c): Returns true if this list contains all of the elements of the specified collection.
4)isEmpty(): Returns true if this list contains no elements.
5)remove(int index): Removes the element at the specified position in this list (optional operation).
6)removeAll(Collection<?> c): Removes from this list all of its elements that are contained in the specified
collection (optional operation).
7)replaceAll(UnaryOperator<E> operator): Replaces each element of this list with the result of applying the operator
to that element.
8)retainAll(Collection<?> c): Retains only the elements in this list that are contained in the specified collection
(optional operation).
9)size(): Returns the number of elements in this list.
10)sort(Comparator<? super E> c): Sorts this list according to the order induced by the specified Comparator.
11)spliterator(): Creates a Spliterator over the elements in this list.
12) toArray(): Returns an array containing all of the elements in this list in proper sequence
(from first to last element).
13) toArray(T[] a): Returns an array containing all of the elements in this list in proper sequence
(from first to last element); the runtime type of the returned array is that of the specified array.
The AbstractList class in Java is an abstract class that provides a skeletal implementation of the List interface.
By extending the AbstractList class, you only need to implement the get and size methods,
which provides a basic implementation of a list.
    Advantages of using AbstractList in Java
1.Reduced code duplication:
By using the AbstractList class as a base, you can reduce the amount of code that you need to write to implement a list,
since many of the common methods have already been implemented for you.
2.Consistent behavior:
Since the AbstractList class implements many of the methods in the List interface,
you can be sure that your implementation will have consistent behavior with other list implementations,
like ArrayList and LinkedList.
    Disadvantages of using AbstractList in Java
1.Limited functionality:
Since the AbstractList class is an abstract class,
it provides only a basic implementation of a list.
You may need to implement additional methods to provide the full functionality required by your application.
2.Increased complexity:
By extending the AbstractList class, you are increasing the complexity of your code,
since you are relying on the base class to provide some of the behavior.

    6. AbstractSequentialList
The AbstractSequentialList class in Java is a part of the Java Collection Framework.
and implements the Collection interface and the AbstractCollection class.
This class provides a skeletal implementation of the List interface to minimize the effort required to implement
this interface backed by a "sequential access" data store.
It is used to implement an unmodifiable list,
for which one needs to only extend this AbstractList Class and implement only the get() and the size() methods.
    Declaration of AbstractSequentialList
public abstract class AbstractSequentialList<E> extends AbstractList<E>
Where E is the type of element maintained by this List.
It implements Iterable<E>, Collection<E>, List<E> interfaces.
LinkedList is the only direct subclass of AbstractSequentialList.
    Constructor: protected AbstractSequentialList()
The default constructor, but being protected
it doesn't allow to create an AbstractSequentialList object.
    Methods of AbstractSequentialList
1)add(int index, E element): Inserts the specified element at the specified position in this list (optional operation).
2) addAll(int index, Collection<? extends E> c): Inserts all of the elements in the specified collection into this
list at the specified position (optional operation).
3)get(int index): Returns the element at the specified position in this list.
4)iterator(): Returns an iterator over the elements in this list (in proper sequence).
5)listIterator(int index): Returns a list iterator over the elements in this list (in proper sequence).
6)remove(int index): Removes the element at the specified position in this list (optional operation).
7)set(int index, E element): Replaces the element at the specified position in this list with the
specified element.
    Methods Inherited From class java.util.AbstractCollection
1) addAll(Collection<? extends E> c): Adds all of the elements in the specified collection to
this collection (optional operation).
2)contains(Object o): Returns true if this collection contains the specified element.
3)containsAll(Collection<?> c): Returns true if this collection contains all of the elements in the specified collection.
4)isEmpty(): Returns true if this collection contains no elements.
5)remove(Object o): Removes a single instance of the specified element from this collection, if it is present (optional operation).
6)removeAll(Collection<?> c): Removes all of this collection's elements that are also contained in the specified
collection (optional operation).
7) retainAll(Collection<?> c): Retains only the elements in this collection that are contained in the specified
collection (optional operation).
8)toArray(): Returns an array containing all of the elements in this collection.
9)toArray(T[] a): Returns an array containing all of the elements in this collection; the runtime type of the
returned array is that of the specified array.
10)toString(): Returns a string representation of this collection.
    Methods Inherited From Interface java.util.Collection
1)parallelStream(): Returns a possibly parallel Stream with this collection as its source.
2)removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that
satisfy the given predicate.
3)stream(): Returns a sequential Stream with this collection as its source.
4)toArray(IntFunction<T[]> generator): Returns an array containing all of the elements in this collection,
using the provided generator function to allocate the returned array.
    Methods Inherited From Interface java.lang.Iterable
1)forEach(Consumer<? super T> action): Performs the given action for each element of the Iterable until all elements
have been processed or the action throws an exception.
    Methods Inherited From Interface java.util.List
1)addAll(Collection<? extends E> c): Appends all of the elements in the specified collection to the end of this list,
in the order that they are returned by the specified collection's iterator (optional operation).
2)contains(Object o): Returns true if this list contains the specified element.
3)containsAll(Collection<?> c): Returns true if this list contains all of the elements of the specified collection.
4)isEmpty(): Returns true if this list contains no elements.
5)remove(Object o): Removes the first occurrence of the specified element from this list,
if it is present (optional operation).
6)removeAll(Collection<?> c): Removes from this list all of its elements that are contained in the specified
collection (optional operation).
7)replaceAll(UnaryOperator<E> operator): Replaces each element of this list with the result of
applying the operator to that element.
8)retainAll(Collection<?> c): Retains only the elements in this list that are contained in the specified
collection (optional operation).
9)size(): Returns the number of elements in this list.
10)sort(Comparator<? super E> c): Sorts this list according to the order induced by the specified Comparator.
11)spliterator(): Creates a Spliterator over the elements in this list.
12)toArray(): Returns an array containing all of the elements in this list in
proper sequence (from first to last element).
13)toArray(T[] a): Returns an array containing all of the elements in this list in proper sequence
(from first to last element); the runtime type of the returned array is that of the specified array.
The AbstractSequentialList class in Java is a subclass of AbstractList that provides a skeletal
implementation of the List interface, specifically for lists that allow sequential access to their elements.
This means that elements can be accessed in a predictable order, such as first to last.
By extending the AbstractSequentialList class, you only need to implement the listIterator and size methods
which provides a basic implementation of a sequential list.
This can save you a lot of time and code compared to implementing the List interface from scratch.
    Advantages of using AbstractSequentialList in Java
1.Reduced code duplication
2.Consistent behavior
    Disadvantages of using AbstractSequentialList in Java
1.Limited functionality
2.Increased complexity

    Set Interface
It represents a collection of unique elements, meaning it does not allow duplicate values.
    Key Features of Set
1.Set does not allow duplicate elements; each item must be unique
2.Elements in a Set are not stored or retrieved in any defined order.
3.LinkedHashSet maintains insertion order, while TreeSet keeps elements sorted.
4.Most Set implementations allow only a single null element.
5.Set supports standard methods like add(), remove(), contains(), size() and iterator() from the Collection interface.
    Creating Set Objects
Since Set is an interface, objects cannot be created of the typeset.
We always need a class that extends this list in order to create an object.
After the introduction of Generics,
it is possible to restrict the type of object that can be stored in the Set.
This type-safe set can be defined as:
    // Obj is the type of the object to be stored in Set
    Set<Obj> set = new HashSet<Obj> ();
Set interface provides commonly used operations to manage unique elements in a collection.
These include:
1.Adding elements
2.Accessing elements
3.Removing elements
4.Iterating elements
    Classes that implement the Set interface
1. HashSet: This is a collection class that implements a hash table-based Set,
storing elements based on their hashcode without maintaining insertion order and allowing one null element.
2. EnumSet: This is a specialized Set implementation for use with enum types
It is part of the Java Collections Framework and offers high performance, often faster than HashSet.
All elements in an EnumSet must belong to the same enum type, defined at creation time.
3. LinkedHashSet: This is an ordered version of HashSet that maintains insertion order,
using a doubly-linked list across all elements.
4. TreeSet: This is a SortedSet implementation that stores elements in ascending order using a tree structure,
ensuring natural ordering or a custom comparator.
    Methods of Set Interface
1)add(element): Adds element if not already present. Returns true if added.
2)addAll(collection): Adds all elements from the given collection.
3)clear(): Removes all elements from the set.
4))contains(element): Checks if the set contains the specified element.
5)containsAll(collection): Checks if the set contains all elements from the given collection.
6)hashCode(): Returns the hash code of the set.
7)isEmpty(): This method is used to check whether the set is empty or not.
8)iterator(): This method is used to return the iterator of the set.
9)remove(element): Removes the specified element from the set.
10)removeAll(collection): Removes all elements in the given collection from the set.
11)retainAll(collection): Retains only elements present in the given collection.
12)size(): Returns the number of elements in the set.
13)toArray(): This method is used to form an array of the same elements as that of the Set.
    HashSet
HashSet in Java implements the Set interface of Collections Framework.
It is used to store the unique elements and it doesn't maintain any specific order of elements.
-Can store the Null values.
-Uses HashMap (implementation of hash table data structure) internally.
-Also implements Serializable and Cloneable interfaces.
-HashSet is not thread-safe. So to make it thread-safe, synchronization is needed externally.
    Capacity of HashSet
Capacity refers to the number of buckets in the hash table.
The default capacity of a HashSet is 16, and the load factor is 0.75.
When the number of elements exceeds the capacity automatically increases (resizes) to maintain performance.
    new capacity = old capacity × 2
Load Factor
Load Factor is a measure that controls how full the HashSet can get before resizing.
Default Load Factor = 0.75. If the number of elements exceeds the threshold, the capacity is doubled.
    Threshold = capacity × load factor
Constructors of HashSet class
To create a HashSet, we need to create an object of the HashSet class.
The HashSet class consists of various constructors that allow the possible creation of the HashSet.
The following are the constructors available in this class.
1. HashSet()
Creates a new empty HashSet with default capacity (16) and load factor (0.75).
syntax
 HashSet<Type> set = new HashSet<>();
2. HashSet(int initialCapacity)
Creates an empty HashSet with the specified initial capacity and default load factor (0.75).
Syntax:
HashSet<Type> set = new HashSet<>(int initialCapacity);
3. HashSet(int initialCapacity, float loadFactor)
Creates an empty HashSet with the given initial capacity and load factor.
Syntax:
HashSet<Type> set = new HashSet<>(int initialCapacity, float loadFactor);
4. HashSet(Collection<? extends E> c)
Creates a new HashSet containing the elements of the specified collection (removes duplicates automatically).
syntax
HashSet<Type> set = new HashSet<>(Collection);
    Performing Various Operations on HashSet
1. Adding Elements in HashSet
To add an element to the HashSet, we can use the add() method.
duplicate elements are not allowed
insertion order is not retained
2. Removing Elements in HashSet
The values can be removed from the HashSet using the remove() method.
3. Iterating through the HashSet
Iterate through the elements of HashSet using the iterator() method
    Methods of HashSet
1)add(E e): Used to add the specified element if it is not present, if it is present then return false.
2)clear(): Used to remove all the elements from the set.
3)contains(Object o): Used to return true if an element is present in a set.
4)remove(Object o): Used to remove the element if it is present in set.
5)iterator(): Used to return an iterator over the element in the set.
6)isEmpty(): Used to check whether the set is empty or not.
Returns true for empty and false for a non-empty condition for set.
7)size(): Used to return the size of the set.
8)clone(): Used to create a shallow copy of the set.
    Differences between HashSet and HashMap.
HashSet                                                 HashMap
1)HashSet implements a Set interface.                   HashMap implements a storesMap interface.
2)HashSet doesn't allow duplicate values.               HashMap stores key-value pairs and doesn’t allow duplicate keys.
                                                        A duplicate key replaces the old value.
3)HashSet requires only one object add(Object o).       HashMap requires two objects put(K key, V Value) to add an element to the HashMap object.
4)HashSet internally uses a HashMap, where each         HashMap does not have any concept of dummy value.
element added is stored as a key with a dummy value.
5)HashSet internally uses the HashMap object to         HashMap internally uses hashing to store or add objects
store or add the objects.
6)HashSet is slower than HashMap.                       HashMap is faster than HashSet.
7)HashSet uses the add() method for adding              HashMap uses the put() method for storing data.
or storing data.
    Traverse through a HashSet in Java
Below are few ways with which we can iterate over elements to perform any kind of operations o
1.Using for-each loop
2.Using forEach method
Stream forEach(Consumer action) performs an action for each element of the stream.
it may traverse the stream to produce a result or a side-effect.
3.Using Iterators
    How to Get Random Elements from Java HashSet?
which can be done by either of the two ways:
1.By converting it to an array
-Firstly convert HashSet into an array and then access the random element from it.
-Then we will create an object of Random class and will call the nextInt() method of that class
which will give us any random number less than or equal to the size of the HashSet.
-And then using an array we will simply print the element present at that index.
2.Using an Iterator or a for loop
-In order to get random elements from the HashSet object,
we need to generate a random number between 0 (inclusive) and the size of the HashSet (exclusive).
-And then iterate through the set till we reach the element located at the random number position as given below.
-In this approach, we will get the element at a random index using an Iterator.
    How to Find the Minimum and Maximum Value from Java HashSet?
There are a couple of ways to find the maximum and minimum from the HashSet in Java.
1.Using Collection class
Using Collections class in Java we can find maximum and minimum
value with the help of max() and min() method of Collections class.
2.Using simple iteration
    How to sort HashSet in Java
The elements of the HashSet can be sorted indirectly by converting into List or TreeSet
    How to convert List to HashSet
The List interface provides a way to store the ordered collection.
The ways to convert List to HashSet :
1.Passing List Object as parameter in HashSet.
2.Adding each element of List into HashSet using loop.
3.Using addAll() Method of Set class.
4.Using stream in Java
Note: Stream only works in Java8 or versions above it.
We use stream in java to convert the given list to stream, then stream to set.
    How to convert Array to HashSet in Java
1)Brute Force or Naive Method
-Create an empty set.
-Iterate the elements of the array and add one by one to the set.
2)Using Java 8 Stream API
-Get the Array to be converted.
-Convert the array to Stream.
-Convert the Stream to Set using Collectors.toSet().
-Collect the formed set using the collect() method.
-Return the formed Set.

    AbstractSet
In Java, the AbstractSet class is part of the Java Collections Framework.
It provides a Skeleton implementation of the set interface.
which is a collection that does not allow duplicate elements
This class is abstract, meaning it cannot be instantiated directly,
but it can be extended to create a custom set implementation
-AbstractSet implements the set interface but does not provide a full implementation of all set methods.
-It provides implementations for methods like size(), isEmpty() and contains()
-It requires subclasses to implement the iterator()method to define how elements are iterated over.
    AbstractSet Class Hierarchy
AbstractSet implements Iterable<E>, Collection<E>, Set<E> interfaces.
The direct subclasses are
CopyOnWriteArraySet, EnumSet, HashSet, TreeSet.
    Declaration of AbstractSet Class
public abstract class AbstractSet<E> extends AbstractCollection<E> implements Set<E>
    Constructor
protected AbstractSet()
This Constructor is used to prevent direct instantiation of the AbstractSet class,
allowing only its subclasses to be instantiated.
    Performing Various Operations on AbstractSet
1. Adding elements
We can use add() method to insert element to a AbstractSet class.
2. Removing Elements
We can use various methods like remove(), removeAll(),
retainAll() and clear() method to remove elements from the AbstractSet.
3.Iterating Elements
We can use the iterator() method to iterate over the elements of a AbstractSet.
    Methods
1.equals(Object o): Compares the specified object with this set for equality.
2.hashCode(): Returns the hash code value for this set.
3.removeAll(Collection<?> c): Removes from this set all of its elements that are contained in the specified collection (optional operation).
    Methods Declared in Class java.util.AbstractCollection
1.add(E e): Ensures that this collection contains the specified element.
2.addAll(Collection<? extends E> c):Adds all of the elements in the specified collection to this collection.
3.clear(): Removes all of the elements from this collection.
4.contains(Object o): Returns true if this collection contains the specified element.
5.containsAll(Collection<?> c): Returns true if this collection contains all of the elements in the specified collection.
6.isEmpty(): Returns true if this collection contains no elements.
7.iterator(): Returns an iterator over the elements contained in this collection.
8.remove(Object o): Removes a single instance of the specified element from this collection, if it is present.
9.retainAll(Collection<?> c): Retains only the elements in this collection that are contained in the specified collection.
10.toArray(): Returns an array containing all of the elements in this collection.
11.toArray(T[] a): Returns an array containing all of the elements in this collection.
12.toString(): Returns a string representation of this collection.
    Methods Declared in Interface java.util.Collection
1.parallelStream(): Returns a possibly parallel Stream with this collection as its source.
2.removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that satisfy the given predicate.
3.stream(): Returns a sequential Stream with this collection as its source.
4.toArray(IntFunction<T[]> generator): Returns an array containing all of the elements in this collection,
using the provided generator function to allocate the returned array.
    Methods Declared in interface java.lang.Iterable
1.forEach(Consumer<? super T> action): Performs the given action for each element of the Iterable until all elements
have been processed or the action throws an exception.
    Methods Declared in interface java.util.Set
1.add(E e)
2.addAll(Collection<? extends E> c)
3.clear()
4.contains(Object o)
5.containsAll(Collection<?> c)
6.isEmpty()
7.iterator()
8.remove(Object o)
9.retainAll(Collection<?> c)
10.size()
11.spliterator()
12.toArray()
13.toArray(T[] a)
    Characteristics of AbstractSet
-Implements the Set interface
-Implements some set methods
-Supports iterator
-Does not implement all set methods
-Provides default implementations
-Supports null elements
-Unordered
-Thread-unsafe

    CopyOnWriteArraySet
This is the part of the java.util.concurrent package and
used to handle thread-safe operations in multi-threaded environments.
-CopyOnWriteArraySet uses a CopyOnWriteArrayList internally.
-Iterators can only perform read operations.
-CopyOnWriteArraySet is Ideal for small sets where read operations are much more frequent than modifications.
-Multiple threads can perform updates simultaneously,
only one thread can iterate the set at a time without encountering ConcurrentModificationException.
-CopyOnWriteArraySet is a class that implements the Set interface.
    Concurrency
Concurrency in Java refers to the ability to execute multiple tasks or parts of a program seemingly simultaneously
    Constructors
1.CopyOnWriteArraySet(): Creates an empty set.
2.CopyOnWriteArraySet(Collection c): Creates a set containing all of the elements of the specified collection.
    Methods
1.add(E e): Adds the specified element to this set if it is not already present.
2.addAll(Collection<? extends E> c): Adds all of the elements in the specified collection to this set if they’re not already present.
3.clear(): Removes all of the elements from this set.
4.contains(Object o): Returns true if this set contains the specified element.
5.containsAll(Collection<?> c): Returns true if this set contains all of the elements of the specified collection.
6.equals(Object o):Compares the specified object with this set for equality.
7.forEach(Consumer<? super E> action): Performs the given action for each element of the Iterable until all elements
have been processed or the action throws an exception.
8.isEmpty(): Returns true if this set contains no elements.
9.iterator(): Returns an iterator over the elements contained in this set in the order in which these elements were added.
10.remove(Object o): Removes the specified element from this set if it is present.
11.removeAll(Collection<?> c): Removes from this set all of its elements that are contained in the specified collection.
12.removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that satisfy the given predicate.
13.retainAll(Collection<?> c): Retains only the elements in this set that are contained in the specified collection.
14.size(): Returns the number of elements in this set.
15.spliterator(): Returns a Spliterator over the elements in this set in the order in which these elements were added.
16.toArray(): Returns an array containing all of the elements in this set.
17.toArray(T[] a): Returns an array containing all of the elements in this set;
the runtime type of the returned array is that of the specified array.
    HashSet                                                                 CopyOnWriteArraySet
1.It belongs to java.util package                                          It belongs to java.util.concurrent package
2.HashSet is not synchronized, meaning it’s not thread-safe.               CopyOnWriteArraySet is synchronized and thread-safe.
    ConcurrentHashMap in Java
In Java, the ConcurrentHashMap is a thread-safe implementation of the Map interface.
It allows multiple threads to read and write data simultaneously
-The default concurrency level of ConcurrentHashMap is 16
    Constructors
-Concurrency-Level: It is the number of threads concurrently updating the map.
-Load-Factor: It’s a threshold, used to control resizing.
-Initial Capacity: Accommodation of a certain number of elements initially provided by the implementation.
    Constructor
-ConcurrentHashMap(): This constructor creates a new, empty map with a default initial capacity (16),
load factor (0.75) and concurrencyLevel (16).
-ConcurrentHashMap(int initialCapacity): This constructor creates a new, empty map with the specified initial capacity,
and with default load factor (0.75) and concurrencyLevel (16).
-ConcurrentHashMap(int initialCapacity, float loadFactor): This constructor creates a new,
empty map with the specified initial capacity and load factor and with the default concurrencyLevel (16)
-ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel):
This constructor creates a new, empty map with the specified initial capacity, load factor, and concurrency level.
-ConcurrentHashMap(Map m): This constructor creates a new map with the same mappings as the given map.
    Performing Various Operations on ConcurrentHashMap
1.Adding Elements: We can use put() or putAll() to insert element to a ConcurrentHashMap.
2.Removing Elements: We can use the remove() method to remove elements from the ConcurrentHashMap.
To clear the entire map, we can use the clear().
3.Accessing Elements: We can use the  get() method to access the elements of the ConcurrentHashMap.
4.Iterating Elements: We can use the Iterator interface to traverse over the elements of ConcurrentHashMap.
Note:
If a thread-safe highly-concurrent implementation is desired,
then it is recommended to use ConcurrentHashMap in place of Hashtable.
    LinkedHashSet
This is very similar to a HashSet.
It combines the functionality of a HashSet with a LinkedList to maintain the insertion order of elements.
-Stores unique elements only.
-Maintains insertion order.
-Provides faster iteration compared to HashSet.
-Allows null elements.
LinkedHashSet maintains insertion order using a doubly-linked list.
Unlike HashSet, it allows predictable iteration in the order elements were added.
    Constructors of LinkedHashSet
1.LinkedHashSet()
This constructor is used to create an empty LinkedHashSet
with the default capacity i.e. 16 and load factor 0.75.
2.LinkedHashSet(Collection C)
Used in initializing the HashSet with the elements of the collection C.
3. LinkedHashSet(int size):
Used to initialize the size of the LinkedHashSet with the integer mentioned in the parameter.
4. LinkedHashSet(int capacity, float fillRatio)
    Performing Various Operations on LinkedHashSet
1.Adding Elements in LinkedHashSet
In order to add an element to the LinkedHashSet, we can use the add()
2.Removing Elements in LinkedHashSet
The values can be removed from the LinkedHashSet using the remove() method.
3.Iterating through the LinkedHashSet
Iterate through the elements of  LinkedHashSet using the iterator() method.
    Advantages of LinkedHashSet
-It maintains insertion order.
-It allows quick insertion, deletion and lookup of elements.
-It is useful for caching applications where insertion order is important.
    Disadvantages of LinkedHashSet
-It takes higher memory as compared to HashSet due to the linked list for maintaining insertion order.
-This is slightly slower operations compared to HashSet because of the linked structure.
    Methods of LinkedHashSet
1.add(E e): Adds an element if it’s not already present.
2.addAll(Collection c): Adds all elements from the specified collection.
3.clear(): Removes all elements from the set.
4.contains(Object o): Checks if the set contains the specified element.
5.containsAll(Collection c): Checks if the set contains all elements from the given collection.
6.remove(Object o): Removes the specified element from the set.
7.removeAll(Collection c): Removes all matching elements from the set.
8.retainAll(Collection c): Keeps only elements present in the given collection.
9.isEmpty(): Checks if the set is empty.
10.size(): Returns the number of elements in the set.
11.iterator(): Returns an iterator over the elements.
12.toArray(): Returns an array containing all elements.
13.toArray(T[] a): Returns an array of the specified type containing all elements.
14.hashCode(): Returns hash code of the set.
15.equals(Object o): Compares this set with another set.
16.clone(): Creates a shallow copy of the set.
17.toString(): Returns a string representation of the set.
18.spliterator(): Returns a Spliterator for this set.
19.stream(): Returns a sequential stream of elements.
20.parallelStream(): Returns a parallel stream of elements.
21.removeIf(Predicate filter): Removes elements that match a condition.
22.forEach(Consumer action): Performs an action on each element.
    Accessing LinkedHashSet elements by Index
Methods:
1.A naive approach using the iteration count method
-Use iterator to traverse to our LinkedHashSet
-Initiate out index pointer currentindex = 0
-Start the iteration using a while loop and if the current
index becomes equal to the given index print the element.
2.Converting LinkedHashSet to Array
-Convert given LinkedHashSet to Array using toArray() method.
-Accessing the element on the given index in the array.
3.Converting LinkedHashSet to List
-Convert our LinkedHashSet to List like ArrayList.
-Using get() method to get an element in a given index.
    Removing elements from a LinkedHashSet
The remove(Object O) method is used to remove a particular element from a LinkedHashSet
This method returns True if the specified element is present in the LinkedHashSet otherwise it returns False.
    Union of Sets in LinkedHashSets
Use the addAll() method to merge two LinkedHashSet objects or
append elements of one LinkedHashSet object to another LinkedHashSet object
-The addAll method adds all the elements of the specified collection to this set object.
    Difference Between LinkedHashSet, TreeSet, and HashSet
-when to use
HashSet
If you don’t want to maintain insertion order but want to store unique objects
LinkedHashSet
If you want to maintain the insertion order of elements then you can use LinkedHashSet
TreeSet
If you want to sort the elements according to some Comparator then use TreeSet

    EnumSet
EnumSet is a specialized set implementation for use with enum types
-It extends the AbstractSet class and implements the Set Interface in Java.
-The EnumSet class is a member of the Java Collections Framework and is not synchronized.
-All of the elements in an EnumSet must come from a single enumeration type
-It does not allow null Objects
-It uses a fail-safe iterator,
    Declaration of EnumSet
In Java, the declaration of EnumSet can be done as
EnumSet<Type> variableName = EnumSet.of(Element1, Element2, Element3);
    Methods
1.allOf(Class<E> elementType): Creates an enum set containing all of the elements in the specified element type.
2.clone(): Returns a copy of this set.
3.complementOf(EnumSet<E> s): Creates an enum set with the same element type as the specified enum set.
4.copyOf(Collection<E> c): Creates an enum set initialized from the specified collection.
5.copyOf(EnumSet<E> s): Creates an enum set with the same element type as the specified enum set.
6.noneOf(Class<E> elementType): Creates an empty enum set with the specified element type.
7.of(E e): Creates an enum set initially containing the specified element.
8.of(E e1, E e2): Creates an enum set initially containing the specified elements.
9.of(E first, E… rest): Creates an enum set initially containing the specified elements.
10.range(E from, E to): Creates an enum set initially containing all of the elements in the range
defined by the two specified endpoints.
    Creating a EnumSet
EnumSet is an abstract class, we can not directly create an instance of it.
EnumSet is an abstract class, we can not directly create an instance of it.
1.RegularEnumSet:
It uses a single long object to store the elements of the EnumSet
-RegularEnumSet can store up to 64 enum values.
2.JumboEnumSet
It uses an array of long values to store the elements of the EnumSet.
The key difference is that JumboEnumSet allows storing more than 63 values
by using multiple long elements to represent a larger set of enum constants.
    Performing Various Operations on EnumSet
1.Adding Elements
We can use add() and addAll() to insert elements to an EnumSet.
2. Accessing Elements
We can access the EnumSet using the iterator() method.
3. Removing Elements
We can use the remove() and removeAll() to remove elements from an EnumSet.
    Methods Declared in Class java.util.AbstractSet
1.equals(Object): Compares the specified object with this set for equality.
2.hashCode(): Returns the hash code value for this set.
3.removeAll(Collection<?> c): Removes from this set all of its elements that are contained in the specified collection.
    Methods Declared in Interface java.util.Collection
1.parallelStream(): Returns a possibly parallel Stream with this collection as its source.
2.removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that satisfy the given predicate.
3.stream(): Returns a sequential Stream with this collection as its source.
4.toArray(IntFunction<T[]> generator): Returns an array containing all of the elements in this collection,
using the provided generator function to allocate the returned array.
    Methods Declared in Interface java.lang.Iterable
1.forEach(Consumer<? super T> action): Performs the given action for each element of the Iterable until
all elements have been processed or the action throws an exception.
    Methods Declared in Interface java.util.Set
1.add(E e): Adds the specified element to this set if it is not already present (optional operation).
2.addAll(Collection<? extends E> c): Adds the specified element to this set if it is not already present.
3.clear(): Removes all of the elements from this set.
4.contains(Object o): Returns true if this set contains the specified element.
5.containsAll(Collection<?> c): Returns true if this set contains all of the elements of the specified collection.
6.isEmpty(): Returns true if this set contains no elements.
7.iterator(): Returns an iterator over the elements in this set.
8.remove(Object o): Removes the specified element from this set if it is present.
9.retainAll(Collection<?> c): Retains only the elements in this set that are contained in the specified collection.
10.size(): Returns the number of elements in this set.
11.spliterator(): Creates a Spliterator over the elements in this set.
12.toArray(): Returns an array containing all of the elements in this set.
    Methods Declared in Class java.util.AbstractCollection
1.add(E e): Ensures that this collection contains the specified element.
2.addAll(Collection<? extends E> c): Adds all of the elements in the specified collection to this collection
3.clear(): Removes all of the elements from this collection
4.contains(Object o): Returns true if this collection contains the specified element.
5.containsAll(Collection<?> c): Returns true if this collection contains all of the elements in the specified collection.
6.isEmpty(): Returns true if this collection contains no elements.
7.iterator(): Returns an iterator over the elements contained in this collection.
8.remove(Object o); Removes a single instance of the specified element from this collection, if it is present.
9.retainAll(Collection<?> c): Retains only the elements in this collection that are contained in the specified collection .
10.toArray(): Returns an array containing all of the elements in this collection.
11.toArray(T[] a): Returns an array containing all of the elements in this collection; the runtime type of the
returned array is that of the specified array.
12. toString(): Returns a string representation of this collection.

    SortedSet Interface
This interface contains the methods inherited from the Set interface
and adds a feature that stores all the elements in this interface to be stored in a sorted manner.
    1.TreeSet
A TreeSet is a collection class that stores unique elements in a sorted order.
In this set The ordering of the elements is maintained by a set using their natural ordering.
The class which implements the navigable set is a TreeSet which is an implementation of a self-balancing tree.
    Key Features of TreeSet
-duplicate insertions are ignored.
-TreeSet does not allow null values.
-Implements the NavigableSet interface and provides navigation methods like higher(), lower(), ceiling() and floor().
-Not thread-safe
    Constructors of TreeSet
In order to create a TreeSet, we need to create an object of the TreeSet class.
The following are the constructors available in this class
1.TreeSet()
Creates an empty TreeSet that sorts elements in their natural order.
    TreeSet ts = new TreeSet();
2.TreeSet(Comparator)
This constructor is used to build an empty TreeSet object in which elements will need an external
specification of the sorting order.
    TreeSet ts = new TreeSet(Comparator comp);
3.TreeSet(Collection)
This constructor is used to build a TreeSet object containing all the elements from the given collection
in which elements will get stored in default natural sorting order
    TreeSet t = new TreeSet(Collection col);
4.TreeSet(SortedSet)
Creates a TreeSet containing the same elements and order as the specified SortedSet.
    TreeSet t = new TreeSet(SortedSet s);
    Various Operations over TreeSet
1. Adding Elements
To add elements to a TreeSet, use the add() method.
2. Accessing the Elements
After adding the elements, if we wish to access the elements,
we can use inbuilt methods like contains(), first(), last(), etc.
3. Removing the Values
The values can be removed from the TreeSet using the remove() method.
4.Iterating the TreeSet
5.StringBuffer
StringBuffer does NOT implement the Comparable interface.
Therefore, you must provide a custom Comparator to use StringBuffer objects in a TreeSet.
  Methods of TreeSet
1.add(Object o): Adds element in sorted order; ignores duplicates.
2.addAll(Collection c): Adds all elements from a collection; ignores duplicates.
3.ceiling?(E e): This method returns the least element in this set greater than or equal to
the given element, or null if there is no such element.
4.clear(): This method will remove all the elements.
5.clone(): The method is used to return a shallow copy of the set, which is just a simple copied set.
6.Comparator(): This method will return the Comparator used to sort elements in TreeSet.
7.contains(Object o): This method will return true if a given element is present in TreeSet else it will return false.
8.descendingIterator?(): This method returns an iterator over the elements in this set in descending order.
9.descendingSet?(): This method returns a reverse order view of the elements contained in this set.
10.first(): This method will return the first element in TreeSet if TreeSet is not null else it will throw NoSuchElementException.
11.floor?(E e): This method returns the greatest element in this set less than or equal to the given element,
or null if there is no such element.
12.headSet(Object toElement): This method will return elements of TreeSet which are less than the specified element.
13.higher?(E e): This method returns the least element in this set strictly greater than the given element,
or null if there is no such element.
14.isEmpty(): This method is used to return true if this set contains no elements or is empty and false for the opposite case.
15.iterator(): Returns an iterator for iterating over the elements of the set.
16.last(): This method will return the last element in TreeSet if TreeSet is not null else it will throw NoSuchElementException.
17.lower?(E e): This method returns the greatest element in this set strictly less than the given element,
or null if there is no such element.
18.pollFirst?(): This method retrieves and removes the first (lowest) element, or returns null if this set is empty.
19.pollLast?(): This method retrieves and removes the last (highest) element, or returns null if this set is empty.
20.remove(Object o): This method is used to return a specific element from the set.
21.size(): This method is used to return the size of the set or the number of elements present in the set.
22.spliterator(): This method creates a late-binding and fail-fast Spliterator over the elements in this set.
23.subSet(Object fromElement, Object toElement): This method will return elements ranging from fromElement to toElement.
24.tailSet(Object fromElement)	This method will return elements of TreeSet which are greater than or equal to the specified element.
    Difference Between EnumSet and TreeSet in Java
-EnumSet is a specialized implementation of the Set interface for enumeration types.
-TreeSet is a class that implementation the SortedSet interface in Java.
    How to Create a TreeSet with a List in Java?
TreeSet can be created from List by passing the List to the TreeSet constructor in Java
we can traverse complete List and adding each element of the List to the TreeSet.
Approach 1:
-Create a List object.
-Enter multiple inputs in the List.
-Create a TreeSet Object.
-Initialize object with a constructor and pass List object in it.
-Print the Treeset.
Approach 2:
-Create a List object.
-Enter multiple inputs in the List.
-Create a TreeSet Object.
-Start List traversal and add that element in the TreeSet.
-After complete traversal, Print the Treeset.
Approach 3
-Initialize and Declare the List object with inputs.
-Now, Create the TreeSet object.
-Collections.addAll() is used to add all elements from one object to another object.
-Print the TreeSet.
    How to Remove Duplicate Entries from an Array using TreeSet
Approach: add() method of Set
    Getting Least Value Element From a Set by Using Sorting Logic on TreeSet in Java
Approach
-Use comparators to order the object of a user-defined class.
-Implementing the sorting functionality that overrides the compare() method to sort the TreeSet by value.
-After sorting, the first object of the TreeSet will be the least value element.

    2.NavigableSet
The NavigableSet is a subtype of the SortedSet interface.
It provides methods to navigate through the elements in the set.
The classes that implement the NavigableSet interface are TreeSet and ConcurrentSkipListSet.
-It allows you to navigate in both directions ascending and descending order
-The most common implementation of NavigableSet is TreeSet.
    Declaration of NavigableSet
NavigableSet<Type> setName;
    Creating NavigableSet Objects
We can not create a NavigableSet directly since it's an interface.
Instead we use a class like TreeSet that implements it.
NavigableSet<Obj> set = new TreeSet<Obj>();
    Performing Various Operations on NavigableSet
1. Adding Elements
We can use the add() method to insert elements to the NavigableSet.
2. Accessing Elements
We can use inbuilt methods like contains(), first(), last(), etc.
3. Removing Elements
The values can be removed from the NavigableSet using the remove(), pollFirst(), pollLast().
4. Iterating Elements
There are various ways to iterate through the NavigableSet.
The most famous one is to use the enhanced for loop.
    Methods
1.ceiling(E e): Returns the least element in this set greater than or equal to the given element,
or null if there is no such element.
2.descendingIterator(): Returns an iterator over the elements in this set, in descending order.
3.descendingSet(): Returns a reverse order view of the elements contained in this set.
4.floor(E e): Returns the greatest element in this set less than or equal to the given element,
or null if there is no such element.
5.headSet(E toElement): Returns a view of the portion of this set whose elements are strictly less than toElement.
6.headSet(E toElement, boolean inclusive): Returns a view of the portion of this set whose elements are less than
(or equal to, if inclusive is true) toElement.
7.higher(E e): Returns the least element in this set strictly greater than the given element,
or null if there is no such element.
8.iterator(): Returns an iterator over the elements in this set, in ascending order.
9.lower(E e): Returns the greatest element in this set strictly less than the given element,
or null if there is no such element.
10.pollFirst(): Retrieves and removes the first (lowest) element, or returns null if this set is empty.
11.pollLast(): Retrieves and removes the last (highest) element, or returns null if this set is empty.
12.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive): Returns a view of the portion of
this set whose elements range from fromElement to toElement.
13.subSet(E fromElement, E toElement): Returns a view of the portion of this set whose elements range from fromElement,
inclusive, to toElement, exclusive.
14.tailSet(E fromElement): Returns a view of the portion of this set whose elements
are greater than or equal to fromElement.
15.tailSet(E fromElement, boolean inclusive): Returns a view of the portion of this set whose elements are
greater than (or equal to, if inclusive is true) fromElement.
    Methods Inherited from Interface java.util.SortedSet
1.comparator(): This method returns the comparator used to order the elements in this set,
or null if this set uses the natural ordering of its elements.
2.first(): This method returns the first(lowest) element present in this set.
3.last(): This method returns the last(highest) element present in the set.
4.spliterator(): Creates a Spliterator over the elements in this sorted set.
    Methods Inherited from Interface java.util.Set
1.add(element): This method is used to add a specific element to the set.
2.addAll(collection): This method is used to append all of the elements from the
mentioned collection to the existing set.
3.clear(): This method is used to remove all the elements from the set but not delete the set.
4.contains(element): This method is used to check whether a specific element is present in the Set or not.
5.containsAll(collection): This method is used to check whether the set contains all the elements
present in the given collection or not.
6.equals(): Compares the specified object with this set for equality.
7.hashCode(): This method is used to get the hashCode value for this instance of the Set.
8.isEmpty(): This method is used to check if a NavigableSet is empty or not.
9.remove(element): This method is used to remove the given element from the set.
10.removeAll(collection): This method is used to remove all the elements from the collection
which are present in the set.
11.retainAll(collection): This method is used to retain all the elements from the set which are
mentioned in the given collection.
12.size(): This method is used to get the size of the set.
13.toArray(): This method is used to form an array of the same elements as that of the Set.
14.toArray(T[] a): Returns an array containing all of the elements in this set.
    Methods Declared in Interface java.util.Collection
1.parallelStream(): Returns a possibly parallel Stream with this collection as its source.
2.removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that satisfy the given predicate.
3.stream(): Returns a sequential Stream with this collection as its source.
4.toArray?(IntFunction<T[]> generator): Returns an array containing all of the elements in this collection, using the
 provided generator function to allocate the returned array.
    Methods Declared in Interface java.lang.Iterable
1)forEach(Consumer<? super T> action): Performs the given action for each element of the Iterable until all elements
have been processed or the action throws an exception.

    3. ConcurrentSkipListSet
