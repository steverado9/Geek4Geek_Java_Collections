    Java Collection Tutorial
Java Collection Framework holds all the collection classes and interfaces.
The Collection interface (java.util.Collection) and Map interface (java.util.Map).
are the two main “root” interfaces of Java collection classes.
    What is a Framework?
A framework is a set of classes and interfaces which provide a ready-made architecture.
-Collection: A group of individual objects that represent a single entity is known as a collection.
-Collection Framework: To represent a group of objects as a single entity in the Java programming
language we need classes and interfaces defined by the Collection Framework.
-Collection Interface: It is the blueprint of the collection class.
-Collections Class: It is present in java.util package and is a member of Collection Framework.
    Advantages of the collections framework
1) Reduces the programming effort as the programmer does not have to worry about designing the Collection class.
On the same hand java being object-oriented language advances in achieving "abstraction".
Abstraction in Java is the process of hiding internal implementation details and showing only essential functionality to the user.
It focuses on what an object does rather than how it does it.
2)Increases program speed and quality as the programmer now is not worried about thinking best implementation for a specific data structure.
3)The API that implements these interfaces are now having common sets of methods be it of any interfaces such as Collection, Set, List, and Map.

Note: All these collections can be imported using:
import java.util.*;

However, single classes can also be imported by replacing * with the class name
import java.util.ArrayList;
import java.util.LinkedList;

The utility package, "java.util" contains all the classes and interfaces that are required by the collection framework.
The collection framework contains an interface named an "iterable interface" which provides the iterator to iterate through all the collections.

    Iterable interface
is the root interface for the entire collection framework.
The main functionality of this interface is to provide an iterator for the collections.

    The following 6 interfaces are described below
    Collection Interface
contains all the basic methods which every collection has
like adding the data into the collection, removing the data, clearing the data, etc
All these methods are implemented in this interface because these methods are implemented by all the
classes irrespective of their style of implementation.
    List Interface
It is a child interface of the collection interface.
It deals with the arrays and lists types of operations like ArrayList, LinkedList, Vector, and Stack.
    1)ArrayList
provides us with dynamic arrays in Java
The size of an ArrayList is increased automatically if the collection grows or shrinks.
    Key Features
-Resizable Array: ArrayList can automatically grow dynamically in size.
-Indexed Access: ArrayList elements can be accessed using indices like arrays.
-Supports Generics: It ensures type safety at compile-time.
-Not Synchronized: ArrayList uses Collections.synchronizedList() for thread safety.
-Allows Null and Duplicates: ArrayList allows both null values and duplicate elements.
-Maintains Insertion Order: Elements are stored in the order they are added.
    Constructors of ArrayList in Java
In order to Create an ArrayList, we need to create an object of the ArrayList class.
The ArrayList class consists of various constructors which allow the possible creation of the array list.
1. ArrayList(): This constructor is used to build an empty array list.
    ArrayList<Integer> arr = new ArrayList<>();
2. ArrayList(Collection c): This constructor is used to build an array list initialized
with the elements from the collection c.
    ArrayList<String> arr = new ArrayList<>(collection);
3. ArrayList(int capacity): This constructor is used to build an array list with the initial capacity being specified.
    ArrayList<Double> arr = new ArrayList<>(20);
    ArrayList methods
1) add() :  is used to add elements to the list.
There are two versions of the ArrayList add() method i.e.
one without specifying an index
and another with a specified index.
2)There are 3 ways to remove an element from ArrayList
-Using remove() method by indexes(default)
-Using remove() method by values
-Using remove() method over iterators
when using iterators,
-next is used to get the current element
-while hasNext is used to check if there is a current element
3)set() Method:  is used to replace an element at a specified position with a new value.
This is very useful when we need to update an existing element in an ArrayList while maintaining the list's structure.
    Syntax of ArrayList set() Method
set(int index, E element)
-index: Index of the element to replace.
-element: Element to be stored at the specified position.
Returns Value: It returns the element that was previously at the specified position.
4) How to Remove Duplicates from ArrayList in Java
-Using Iterator
step1: Get the ArrayList with duplicate values.
step2: Create another ArrayList.
step3: Traverse through the first arraylist and store the first appearance of each element into the second arraylist using contains() method.
step4: The second ArrayList contains the elements with duplicates removed.
-using LinkedHashSet
A better way  is to remove duplicates from an ArrayList is to convert it into a Set that does not allow duplicates.
Hence LinkedHashSet is the best option available as this do not allows duplicates as well it preserves the insertion order.
-Using Java 8 Stream.distinct()
You can use the distinct() method from the Stream API
The distinct() method return a new Stream without duplicates elements based on the result returned by equals() method,
which can be used for further processing .
 The actual processing of Stream pipeline starts only after calling terminal methods like forEach() or collect().
5)How to reverse an ArrayList
-a). By writing our own function()
    logic 1
reverseArrayList() method in RevArrayList class contains logic for reversing an arraylist with integer objects.
This method takes an arraylist as a parameter, traverses in reverse order and adds all the elements to the newly created arraylist.
Finally the reversed arraylist is returned.
    logic 2
- Run the loop for n/2 times where 'n' is the number of elements in the arraylist.
- In the first pass, Swap the first and nth element
-In the second pass, Swap the second and (n-1)th element and so on till you reach the mid of the arraylist.
-Return the arraylist after the loop termination.
-b). By using Collections class:
Collections is a class in java.util package which contains various static methods for searching, sorting, reversing, finding max, min....etc
We can make use of the In-built Collections.reverse() method for reversing an arraylist.
It takes a list as an input parameter and returns the reversed list.
-c)Reversing an arraylist of user defined objects
The arraylist is reversed using In-built reverse() method of Collections class.
-d)Using ListIterator

6)Convertng ArrayList to String Array
ArrayList class is derived from the List interface.
Here we are given an ArrayList of strings and the task is to convert the ArrayList to a string array.
Methods:
    Using get() method of ArrayList class
-Get the ArrayList of Strings.
-Find the size of ArrayList using size() method, and Create a String Array of this size.
-Fetch each element of the ArrayList one by one using get() method.
-Assigned each element into String Array using assignment(=) operator.
-Printing string array.
    Using toArray() method of ArrayList class
Here we will be creating an object array to store elements received from ArrayList by creating an array of strings.
-Get the ArrayList of String.
-Convert ArrayList to Object array using toArray() method.
-Iterate and convert each element to the desired type using typecasting.
-Here it is converted to String type and added to the string array.
-Print the string array
    Using copyOf() method of Arrays class
-Get the ArrayList of String
-Convert ArrayList to Object array using toArray() method.
-Convert it to String Array using Arrays.copyOf() method.
-Print String Array.

7)Getting a sub-list from an ArrayList
The subList() method of the ArrayList class in Java is used to retrieve a portion of an ArrayList between specified indices.
When we perform any modifications to the sub list, that will reflect in the original list and vice versa.
    Syntax of ArrayList subList() Method
public List<E> subList(int fromIndex, int toIndex);
    Parameters:
fromIndex: Starting index (inclusive) of the sublist.
toIndex: Ending index (exclusive) of the sublist.
Returns Value: It returns a view of the portion of this list between the specified indices.
    Exception: This method throws the following Exceptions.
-IndexOutOfBoundsException: If an endpoint index value is out of range (fromIndex > size).
-IllegalArgumentException: If an endpoint indices are out of order (fromIndex > toIndex).

    2)LinkedList
Linked List is a part of the Collection framework present in java.util package.
This class is an implementation of the LinkedList data structure,
which is a linear data structure where the elements are
linked using pointers and addresses, and each element is known as a node.
This class is an implementation of a doubly-linked list data structure.
Note: The nodes cannot be accessed directly instead we have to start from the head and follow the
link until we find the node that we want.
    Internal Working of LinkedList
The size of the list automatically increases when we dynamically add and remove items.
Internally, the LinkedList is implemented using the doubly linked list data structure.
-Doubly linked list:
Each node in a Doubly Linked List contains the data it holds,
a pointer to the next node in the list, and a pointer to the previous node in the list.
We can traverse the list in both directions (forward and backward), which is a key feature of a Doubly Linked List.
    Constructors in the LinkedList
In order to create a LinkedList, we need to create an object of the LinkedList class.
The LinkedList class consists of various constructors that allow the possible creation of the list.
1)LinkedList(): This constructor is used to create an empty linked list.
2) LinkedList(Collection C): This constructor is used to create an ordered list that contains all the elements of a specified collection,
as returned by the collection's iterator.
    Methods for Java LinkedList
1)add(index, element): This method inserts the specified element at the specified position in the list.
2)add(element): This method Appends the specified element to the end of the list.
3)addAll(index, Collection<E>): This method Inserts all of the elements in the specified collection into this list,
starting at the specified position.
4)addAll(Collection<E>): This method Appends all of the elements in the specified collection to the end of this list,
in the order that they are returned by the specified collection's iterator.
5)addFirst(Element): This method Inserts the specified element at the beginning of this list.
6)addLast(Element): This method Appends the specified element to the end of this list.
7)clear(): This method removes all of the elements from this list.\
8)clone(): This method returns a shallow copy of this LinkedList.
9)contains(Object o): This method returns true if this list contains the specified element.
10)descendingIterator(): This method returns an iterator over the elements in this deque in reverse sequential order.
11)element(): This method retrieves but does not remove, the head (first element) of this list.
12)get(int index): This method returns the element at the specified position in this list.
13)getFirst(): This method returns the first element in this list.
14)getLast(): This method returns the last element in this list.
15)indexOf(Object o): This method returns the index of the first occurrence of the specified element in this list,
or -1 if this list does not contain the element.
16)lastIndexOf(Object o): This method returns the index of the last occurrence of the specified element in this list,
or -1 if this list does not contain the element.
17)listIterator(int index): This method returns a list-iterator of the elements in this list (in proper sequence),
starting at the specified position in the list.
18)offer(E e): This method Adds the specified element as the tail (last element) of this list.
19)offerFirst(E e): This method Inserts the specified element at the front of this list.
20)offerLast(E e): This method Inserts the specified element at the end of this list.
21)peek(): This method retrieves but does not remove, the head (first element) of this list.
22)peekFirst(): This method retrieves, but does not remove, the first element of this list, or returns null if this list is empty.
23)peekLast(): This method retrieves, but does not remove, the last element of this list, or returns null if this list is empty.
24)poll(): This method retrieves and removes the head (first element) of this list.
25)pollFirst(): This method retrieves and removes the first element of this list, or returns null if this list is empty.
26)pollLast(): This method retrieves and removes the last element of this list, or returns null if this list is empty.
27)pop(): This method Pops an element from the stack represented by this list.
28)push(E e): This method pushes an element onto the stack represented by this list.
29)remove(): This method retrieves and removes the head (first element) of this list.
30)remove(int index): This method removes the element at the specified position in this list.
31)remove(Object o): This method removes the first occurrence of the specified element from this list if it is present.
32)removeFirst(): This method removes and returns the first element from this list.
33)removeFirstOccurrence(Object o): This method removes the first occurrence of the specified element in this list
(when traversing the list from head to tail).
34)removeLast(): This method removes and returns the last element from this list.
35)removeLastOccurrence(Object o): This method removes the last occurrence of the specified element in this list
(when traversing the list from head to tail).
36)set(int index, E element): This method replaces the element at the specified position in this list with the specified element.
37)size(): This method returns the number of elements in this list.
38)spliterator(): This method creates a late-binding and fail-fast Spliterator over the elements in this list.
39)toArray(): This method returns an array containing all of the elements in this list in proper sequence (from first to last element).
40)toArray(T[] a): This method returns an array containing all of the elements in this list in proper sequence
(from first to last element); the runtime type of the returned array is that of the specified array.
41)toString(): This method returns a string containing all of the elements in this list in proper sequence (from first to the last element),
each element is separated by commas and the String is enclosed in square brackets.
    The classes that implement the list interface.
-AbstractList: This class is used to implement an unmodifiable list,
for which one needs to only extend this AbstractList Class and implement only the get() and the size() methods.
-CopyOnWriteArrayList: This class implements the list interface.
It is an enhanced version of ArrayList in which all the modifications(add, set, remove, etc.) are implemented by making a fresh copy of the list.
    Accessing elements of a linked list
In Java, the get() method of LinkedList is used to fetch or retrieve an element at a specific index from a LinkedList.
    Check if the LinkedList contains the Element
In Java, the contains() method of LinkedList is used to check whether an element is present in a LinkedList or not.
It takes the element as a parameter and returns True if the element is present in the list.
    Remove All Elements from a LinkedList
In Java, the clear() is used to remove all the elements from a LinkedList.
This method only clears all the element from the list and not deletes the list.
After calling this method, the list will be empty.
    Iterate over LinkedList using Iterator
In Java, the listIterator() method of the LinkedList class returns
a ListIterator that allows us to iterate over the elements of the list.
Now there are two versions of listIterator() method i.e. without index and with an index.
1. listIterator() Method with No Parameters
It creates an ListIterator that starts form the beginning of the list.
2. listIterator() Method with an Index
The listIterator(int index) method creates a ListIterator that starts iterating from the specified index in the list.

    3)Vector
Vector is a resizable array in Java, found in the java.util package.
It is part of the Collection Framework and works like an ArrayList,
but it is synchronized,
meaning it is safe to use in multi-threaded programs.
However, this makes it a bit slower than ArrayList.
   Key Features of Vector
-It expands as elements are added.
-The Vector class is synchronized in nature means it is thread-safe by default.
-Like an ArrayList, it maintains insertion order.
-It allows duplicates and nulls.
-It implements List, RandomAccess, Cloneable and Serializable.
    Vector Capacity in Java
When a Vector is created using the default constructor, it is initialized with a default capacity of 10.
This means it can hold up to 10 elements before needing to grow in size.
If the number of elements exceeds the current capacity, the Vector automatically increases its capacity.
    Formula to calculate new capacity
newCapacity = oldCapacity * 2
    Constructors of Vector
1. Vector(): Creates a default vector of the initial capacity is 10.
    Vector<E> v = new Vector<E>();
2. Vector(int size): Creates a vector whose initial capacity is specified by size.
    Vector<E> v = new Vector<E>(int size);
3. Vector(int size, int incr):  Creates a vector whose initial capacity is specified by size and increment is specified by incr.
It specifies the number of elements to allocate each time a vector is resized upward.
4. Vector(Collection c): Creates a vector that contains the elements of collection c.
Note:
-If the vector increment is not specified then it’s capacity will be doubled in every increment cycle.
-The capacity of a vector cannot be below the size, it may equal to it.
1) adding elements in a vector
To add the elements to the Vector, we use the add() method.
-add(Object): This method is used to add an element at the end of the Vector.
-add(int index, Object): This method is used to add an element at a specific index in the Vector.
2) Updating Elements
To update an element in a Vector, use the set() method.
It takes the index and the new element to replace the existing one at that position.
3) Removing Elements
To remove an element from a Vector, we can use the remove() method.
They are:
-remove(Object): This method is used to remove an object from the Vector.
If there are multiple such objects, then the first occurrence of the object is removed.
-remove(int index): This method takes an integer value which simply removes the element present at that specific index in the Vector.
After removing the element, all the elements are moved to the left to fill the space and the indices of the objects are updated.
4) Iterating the Vector
The most famous ways are by using the basic for loop in combination with a get() method to get the element at
a specific index and the advanced for loop.
    Vector vs ArrayList in Java
ArrayList and Vectors both implement the List interface,
and both use (dynamically resizable) arrays for their internal data structure.
      ArrayList	                        Vector
1) ArrayList is not synchronized.       Vector is synchronized.
2) ArrayList increments 50% of the      Vector increments 100% means doubles the array size
    current array size if the number    if the total number of elements exceeds its capacity.
 of elements exceeds its capacity.
3)ArrayList is not a legacy class.      Vector is a legacy class.
4)ArrayList is fast because             Vector is slow because it is synchronized.
it is non-synchronized.
5)ArrayList uses the Iterator           A Vector can use the Iterator interface or
interface to traverse the elements      Enumeration interface to traverse the elements.
6)ArrayList performance is high         Vector performance is low.
7)Multiple threads is allowed           only one threads are allowed.
    Significant Differences between ArrayList and Vector
Synchronization:
Vector is synchronized, which means only one thread at a time can access the code.
while ArrayList is not synchronized, which means multiple threads can work on ArrayList at the same time.
    Disadvantages of using Vector in Java
1)The synchronization in Vector can lead to slower performance compared to other collection classes, such as ArrayList.
2)If you don't need the synchronization features of Vector, using it will add unnecessary overhead to your code.
    Methods in Vector Class
1)add(E e): Appends the specified element to the end of this Vector.
2)add(int index, E element): Inserts the specified element at the specified position in this Vector.
3)addAll(Collection<?extends E> c): Appends all elements from the given collection to the end of this Vector.
4)addAll(int index,Collection<? extends E> c): Insert all of the elements in the specified Collection into this
Vector at the specified position.
5)addElement(E obj): Adds the specified element to the end, increasing size by one.
6)capacity(): Returns the current capacity of this vector.
7)clear(): Removes all of the elements from this Vector.
8)clone(): Returns a clone of this vector.
9)contains(Object o): Returns true if this vector contains the specified element.
10)containsAll(Collection<?> c): Returns true if this Vector contains all of the elements in the specified Collection.
11)copyInto(Object[] anArray): Copies the components of this vector into the specified array.
12)elementAt(int index): Returns the component at the specified index.
13)elements(): Returns an enumeration of the components of this vector.
14)ensureCapacity(int minCapacity): Increases capacity to ensure it can hold at least the specified number of elements.
15)equals(Object o): Compares the specified Object with this Vector for equality.
16)firstElement(): Returns the first component (the item at index 0) of this vector.
17)forEach(Consumer<?super E> action): Performs the given action for each element of the Iterable until all elements
have been processed or the action throws an exception.
18)get(int index): Returns the element at the specified position in this Vector.
19)hashCode(): Returns the hash code value for this Vector.
20)indexOf(Object o): Returns index of the first occurrence of the element or -1 if not found.
21)indexOf(Object o, int index): Returns index of the first occurrence starting from the given index.
22)insertElementAt(E obj, int index): Inserts the specified object as a component in this vector at the specified index.
23)isEmpty(): Tests if this vector has no components.
24)iterator(): Returns an iterator over the elements in this list in a proper sequence.
25)lastElement(): Returns the last component of the vector.
26)lastIndexOf(Object o): Returns the index of the last occurrence of the element or -1 if not found.
27)lastIndexOf(Object o, int index): Returns index of the last occurrence before the given index.
28)listIterator(): Returns a list iterator over the elements in this list (in proper sequence).
29)listIterator(int index): Returns a list iterator over the elements in this list (in proper sequence),
starting at the specified position in the list.
30)remove(int index): Removes the element at the specified position in this Vector.
31)remove(Object o): Removes the first occurrence of the specified element.
32)removeAll(Collection<?> c): Removes from this Vector all of its elements contained in the specified Collection.
33)removeAllElements(): Removes all components from this vector and sets its size to zero.
34)removeElement(Object obj): Removes the first (lowest-indexed) occurrence of the argument from this vector.
35)removeElementAt(int index): Deletes the component at the specified index.
36)removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that satisfy the given predicate.
37)removeRange(int fromIndex,int toIndex): Removes from this list all of the elements whose index is between fromIndex,
inclusive and toIndex, exclusive.
38)replaceAll(UnaryOperator<E> operator): Replaces each element of this list with the result of applying the operator to that element.
39)retainAll(Collection<?> c): Retains only the elements in this Vector contained in the specified Collection.
40)set(int index, E element): Replaces the element at the specified position in this Vector with the specified element.
41)setElementAt(E obj, int index): Sets the component at the specified index of this vector to be the specified object.
42)setSize(int newSize): Sets the size of this vector.
43)size(): Returns the number of components in this vector.
44)sort(Comparator<? super E> c): Sorts this list according to the order induced by the specified Comparator.
45)spliterator(): Creates a late-binding and fail-fast Spliterator over the elements in this list.
46)subList(int fromIndex, int toIndex): Returns a view of the portion of this List between fromIndex,
inclusive and toIndex, exclusive.
47)toArray(): Returns an array containing all of the elements in this Vector in the correct order.
48)toArray(T[] a): Returns an array containing all the elements.
49)toString(): Returns a string representation of this Vector, containing the String representation of each element.
50)trimToSize(): Trims the capacity of this vector to be the vector's current size.
     Vector provides us with dynamic arrays in Java.
This is a legacy class. It is a thread-safe class.
This is not recommended being used in a single-threaded environment as it might cause extra overheads.
However, to overcome this in Vectors place one can readily use ArrayList.
A single-threaded environment is one where a program can only execute one task at a time.
    How to check if a vector is empty
The Java.util.Vector.isEmpty() method in Java is used to check and verify if a Vector is empty or not.
It returns True if the Vector is empty else it returns False.
    How to Iterate the Vector Elements in the Reverse Order in Java
We will be using two methods:
1)Using For Loop
2)Using ListIterator
The ListIterator method takes the starting index from where traversal has to begin and returns the ListIterator.
ListIterator has methods to traversal forward as well as backward.
We will pass starting index as equal to the size of the array, and then we will use the hasPrevious() method of ListIterator,
in which we will print the backward element to the current index if exists.
    How to copy one java Vector to Another Vector in java
Previously vector was a part of legacy classes but now it is part of Collections.
It also implements a List interface, so we can use any method of list interface on vectors also.
    Ways To copy elements of one vector to another:
1)Passing in the constructor
-In this approach, we will simply pass the one Vector into the other Vector's constructor.
-By using this approach if we change in first vector values then it will not change the values of the second vector.
This is the easiest way of duplicating the vector values.
2)Adding one by one using add() method
-In this approach, we will iterate over each element of  Vector and add that element in the second Vector.
-Here if you change the first Vector element then it will not change the elements of the second Vector.
-It is not the best approach but it's a simple iteration process.
    How to Find the Minimum or Maximum Element from the Vector in Java?
Methods:
1)Using Collection.min() and Collection.max() methods.
Collections package offers a static method of finding the minimum and maximum in a collection.
These methods are Collections.max() and Collections.min().
-Collections.max() finds the maximum element
-Collections.min() finds the minimum element in a collection.
2)Using Iterating over vector elements setting min-max.
-Take a variable say minNumber, and initialized to the maximum value later on to compare and update.
-Take a variable say maxNumber, and initialized to minimum value later on to compare an update.
-Iterate through Vector and compare each element with the above two-variable -
 minNumber
 maxNumber
 -If the number is less than minNumber, update the value of minNumber.
 -If the number is greater than maxNumber, update the value of maxNumber.

    4)Stack
This class is based on the basic principle of last-in-first-out.
This is a legacy class.
This inherits from a Vector class.
It is also a thread-safe class.
This is not recommended being used in a single-threaded environment as it might cause extra overheads.
However, to overcome this in Vectors place one can readily use ArrayDeque.
-ArrayDeque: ArrayDeque is a resizable array implementation of the Deque interface.
which stands for double-ended queue.
-It allows elements to be added or removed from both ends efficiently.
-It can be used as a stack (LIFO) or a queue (FIFO).
-Operations like addFirst(), addLast(), removeFirst(), removeLast() are all done in constant time O(1).
-The ArrayDeque class implements these two interfaces Queue interface and Deque interface.
support concurrent access by multiple threads.
In Java, a Stack is a linear data structure that follows the Last In First Out (LIFO) principle.
and is defined in the java.util package
Internally, it extends the Vector class.
    Key Characteristics of Vector
-Maintains insertion order
-Allows duplicate and null values
-Grows dynamically when capacity is exceeded
-Implements List, RandomAccess, Cloneable and Serializable interfaces.
-Inherits from the AbstractList class
    How to Create a Stack?
In order to create a stack, we must import java.util.stack package
and use the Stack() constructor of this class.
    Performing Different Operations on Stack Class
1. Adding Elements: With the help of push() method we can add element to the stack.
The push() method place the element at the top of the stack.
lifo- last element to enter a stack is the first element to be removed from a stack
2. Accessing the Element: With the help of peek() method we can fetch the top element of the stack.
3. Removing Elements: With the help of pop() method we can delete and return the top element from the stack.
    Prioritize Use of Deque over Stack
The Stack class in Java is inherits from Vector in Java.
It is a thread-safe class.
It is recommended to use ArrayDeque for stack implementation as it is more efficient in a single-threaded environment.
    Methods in Stack Class
1)empty(): This method returns true if nothing is on the top of the stack. Else, returns false.
2)peek(): This method returns the element on the top of the stack, but does not remove it.
3)pop(): This method removes and returns the top element of the stack.
4)push(Object element): This method pushes an element on the top of the stack.
5)search(Object element): This method is used to determine whether an object exists in the stack.
If the element is found,It returns the position of the element from the top of the stack. Else, it returns -1.
    Methods Inherited from the Vector Class
1)add(Object obj): This method is used to appends the specified element to the end of the Vector.
2)add(int index, Object obj): This method is used to inserts the specified element at the specified position in the Vector.
3)addAll(Collection c): This method is used to appends all of the elements in the specified Collection to the end of the Vector,
in the order that they are returned by the specified Collection's Iterator.
4)addAll(int index, Collection c): This method is used to inserts all the elements in the specified Collection into this Vector at the specified position.
5)addElement(Object o): This method is used to adds the specified component to the end of the vector.
6)capacity(): This method returns the current capacity of the vector.
7)clear(): This method removes all the elements from the Vector.
8)clone(): This method returns a clone of the vector.
9)contains(Object o): This method returns true if this vector contains the specified element.
10)containsAll(Collection c): This method returns true if this Vector contains all the elements in the specified Collection.
11)copyInto(Object []array): This method is used to copy the components of this vector into the specified array.
12)elementAt(int index): This method returns the component at the specified index.
13)elements(): This method returns an enumeration of the components of the vector.
14)ensureCapacity(int minCapacity): This method increases the capacity of the vector,
if necessary, to ensure that it can hold at least the number of components specified by the minimum capacity argument.
15)equals(): This method compares the specified Object with the Vector for equality.
16)firstElement(): This method returns the first component (the item at index 0) of the vector.
17)get(int index): This method returns the element at the specified position in the Vector.
18)hashCode(): This method returns the hash code value for the Vector.
19)indexOf(Object o): This method returns the index of the first occurrence of the specified element
in this vector or -1 if this vector does not contain the element.
20)indexOf(Object o, int index): This method returns the index of the first occurrence of the specified element in this vector,
searching forwards from the index or returns -1 if the element is not found.
21)insertElementAt(Object o, int index): This method inserts the specified object as a component in this vector
at the specified index.
22)isEmpty(): This method tests if this vector has no components.
23)iterator(): This method returns an iterator over the elements in this list in proper sequence.
24)lastElement(): This method returns the last component of the vector.
25)lastIndexOf(Object o): This method returns the index of the last occurrence of the specified element
in this vector or -1 If this vector does not contain the element.
26)lastIndexOf(Object o, int index): This method returns the index of the last occurrence of the specified element in this vector,
searching backward from the index or returns -1 if the element is not found.
27)listIterator(): This method returns a list iterator over the elements in this list (in proper sequence).
28)listIterator(int index): This method returns a list iterator over the elements in this list (in proper sequence),
starting at the specified position in the list.
29)remove(int index): This method removes the element at the specified position in this Vector.
30)remove(Object o): This method removes the first occurrence of the specified element in this Vector
If the Vector does not contain the element, it is unchanged.
31)removeAll(Collection c): This method removes from this Vector all of its elements that are contained in the specified Collection.
32)removeAllElements(): This method removes all components from this vector and sets its size to zero.
33)removeElement(Object o): This method removes the first (lowest-indexed) occurrence of the argument from this vector.
34)removeElementAt(int index): This method deletes the component at the specified index.
35)removeRange(int fromIndex, int toIndex): This method removes from this list all the elements whose index is between
fromIndex, inclusive, and toIndex, exclusive.
36)retainAll(Collection c): This method retains only the elements in this Vector that are contained in the specified Collection.
37)set(int index, Object o): This method replaces the element at the specified position in this Vector with the specified element.
38)setElementAt(Object o, int index): This method sets the component at the specified index of this vector to be the specified object.
39)setSize(int newSize): This method sets the size of this vector.
40)size(): This method returns the number of components in this vector.
41)subList(int fromIndex, int toIndex): This method returns a view of the portion of this List between fromIndex,
inclusive, and toIndex, exclusive.
42)toArray(): This method returns an array containing all of the elements in this Vector in the correct order.
43)toArray(Object []array): This method returns an array containing all of the elements in this Vector in the
correct order; the runtime type of the returned array is that of the specified array.
44)toString(): This method returns a string representation of this Vector, containing the String representation of each element.
45)trimToSize(): This method trims the capacity of this vector to be the vector's current size.
    How to check if a stack is empty
The java.util.Stack.empty() method in Java is used to check whether a stack is empty or not.
The method is of boolean type and returns true if the stack is empty else false.
    How to Search Element in Stacks
The java.util.Stack.search(Object element) method in Java is used to search for an element in the stack and get its distance from the top.
This method starts the count of the position from 1 and not from 0.
The element that is on the top of the stack is considered to be at position 1.
The method returns its position if the element is successfully found and returns -1 if the element is absent.
Parameters: The method accepts one parameter element which refers to the element that is required to be searched for in the Stack.

    5)Abstract List
The AbstractList class in Java is a part of the Java Collection Framework.
It implements the Collection interface and the AbstractCollection class.
"AbstractCollection":  This is an unmodifiable collection.
AbstractList class provides a skeletal implementation of the List interface,
to minimize the effort required to implement this interface.
Note: For sequential access data (such as a linked list),
"AbstractSequentialList" should be used in preference to this class.
    Constructor: protected AbstractList()
This is the default constructor, but being protected, it doesn't allow to create an AbstractList object.
    Methods in AbstractList
1)add(int index, E element): Inserts the specified element at the specified position in this list (optional operation).
2)add(E e):Appends the specified element to the end of this list (optional operation).
3)addAll(int index, Collection<? extends E> c): Inserts all of the elements in the specified collection
into this list at the specified position (optional operation).
4)clear(): Removes all of the elements from this list (optional operation).
5)equals(Object o): Compares the specified object with this list for equality.
6)get(int index): Returns the element at the specified position in this list.
7)hashCode(): Returns the hash code value for this list.
8)indexOf(Object o): Returns the index of the first occurrence of the specified element in this list,
or -1 if this list does not contain the element.
9) iterator(): Returns an iterator over the elements in this list in proper sequence.
10)lastIndexOf(Object o): Returns the index of the last occurrence of the specified element in this list,
or -1 if this list does not contain the element.
11)listIterator(): Returns a list iterator over the elements in this list (in proper sequence).
12)listIterator(int index): Returns a list iterator over the elements in this list (in proper sequence),
starting at the specified position in the list.
13)remove(int index): Removes the element at the specified position in this list (optional operation).
14) removeRange(int fromIndex, int toIndex): Removes from this list all of the elements whose index is between
fromIndex, inclusive, and toIndex, exclusive.
15) set(int index, E element): Replaces the element at the specified position in this list with the
specified element (optional operation)
16) subList(int fromIndex, int toIndex): Returns a view of the portion of this list between the specified fromIndex,
inclusive, and toIndex, exclusive.
    Methods declared in class java.util.AbstractCollection
1)addAll(Collection<? extends E> c): Adds all of the elements in the specified collection to this
collection (optional operation).
2)contains(Object o): Returns true if this collection contains the specified element.
3)containsAll(Collection<?> c): Returns true if this collection contains all of the elements in the specified collection.
4)isEmpty(): Returns true if this collection contains no elements.
5) remove(Object o): Removes a single instance of the specified element from this collection, if it is present (optional operation).
7)removeAll(Collection<?> c): Removes all of this collection's elements that are also contained in the specified
collection (optional operation).
8) retainAll(Collection<?> c): Retains only the elements in this collection that are contained in the specified
collection (optional operation).
9) toArray(): Returns an array containing all of the elements in this collection.
10)toArray(T[] a): Returns an array containing all of the elements in this collection; the runtime type of the returned
array is that of the specified array.
11) toString(): Returns a string representation of this collection.
    Methods declared in interface java.util.Collection
1)parallelStream(): Returns a possibly parallel Stream with this collection as its source.
2)removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that
satisfy the given predicate.
3)stream(): Returns a sequential Stream with this collection as its source.
4)toArray(IntFunction<T[]> generator): Returns an array containing all of the elements in this collection, using the
provided generator function to allocate the returned array.
    Methods declared in interface java.util.List
1)addAll(Collection<? extends E> c): Appends all of the elements in the specified collection to the end of this list,
in the order that they are returned by the specified collection's iterator (optional operation).
2)contains(Object o): Returns true if this list contains the specified element.
3) containsAll(Collection<?> c): Returns true if this list contains all of the elements of the specified collection.
4)isEmpty(): Returns true if this list contains no elements.
5)remove(int index): Removes the element at the specified position in this list (optional operation).
6)removeAll(Collection<?> c): Removes from this list all of its elements that are contained in the specified
collection (optional operation).
7)replaceAll(UnaryOperator<E> operator): Replaces each element of this list with the result of applying the operator
to that element.
8)retainAll(Collection<?> c): Retains only the elements in this list that are contained in the specified collection
(optional operation).
9)size(): Returns the number of elements in this list.
10)sort(Comparator<? super E> c): Sorts this list according to the order induced by the specified Comparator.
11)spliterator(): Creates a Spliterator over the elements in this list.
12) toArray(): Returns an array containing all of the elements in this list in proper sequence
(from first to last element).
13) toArray(T[] a): Returns an array containing all of the elements in this list in proper sequence
(from first to last element); the runtime type of the returned array is that of the specified array.
The AbstractList class in Java is an abstract class that provides a skeletal implementation of the List interface.
By extending the AbstractList class, you only need to implement the get and size methods,
which provides a basic implementation of a list.
    Advantages of using AbstractList in Java
1.Reduced code duplication:
By using the AbstractList class as a base, you can reduce the amount of code that you need to write to implement a list,
since many of the common methods have already been implemented for you.
2.Consistent behavior:
Since the AbstractList class implements many of the methods in the List interface,
you can be sure that your implementation will have consistent behavior with other list implementations,
like ArrayList and LinkedList.
    Disadvantages of using AbstractList in Java
1.Limited functionality:
Since the AbstractList class is an abstract class,
it provides only a basic implementation of a list.
You may need to implement additional methods to provide the full functionality required by your application.
2.Increased complexity:
By extending the AbstractList class, you are increasing the complexity of your code,
since you are relying on the base class to provide some of the behavior.

    6. AbstractSequentialList
The AbstractSequentialList class in Java is a part of the Java Collection Framework.
and implements the Collection interface and the AbstractCollection class.
This class provides a skeletal implementation of the List interface to minimize the effort required to implement
this interface backed by a "sequential access" data store.
It is used to implement an unmodifiable list,
for which one needs to only extend this AbstractList Class and implement only the get() and the size() methods.
    Declaration of AbstractSequentialList
public abstract class AbstractSequentialList<E> extends AbstractList<E>
Where E is the type of element maintained by this List.
It implements Iterable<E>, Collection<E>, List<E> interfaces.
LinkedList is the only direct subclass of AbstractSequentialList.
    Constructor: protected AbstractSequentialList()
The default constructor, but being protected
it doesn't allow to create an AbstractSequentialList object.
    Methods of AbstractSequentialList
1)add(int index, E element): Inserts the specified element at the specified position in this list (optional operation).
2) addAll(int index, Collection<? extends E> c): Inserts all of the elements in the specified collection into this
list at the specified position (optional operation).
3)get(int index): Returns the element at the specified position in this list.
4)iterator(): Returns an iterator over the elements in this list (in proper sequence).
5)listIterator(int index): Returns a list iterator over the elements in this list (in proper sequence).
6)remove(int index): Removes the element at the specified position in this list (optional operation).
7)set(int index, E element): Replaces the element at the specified position in this list with the
specified element.
    Methods Inherited From class java.util.AbstractCollection
1) addAll(Collection<? extends E> c): Adds all of the elements in the specified collection to
this collection (optional operation).
2)contains(Object o): Returns true if this collection contains the specified element.
3)containsAll(Collection<?> c): Returns true if this collection contains all of the elements in the specified collection.
4)isEmpty(): Returns true if this collection contains no elements.
5)remove(Object o): Removes a single instance of the specified element from this collection, if it is present (optional operation).
6)removeAll(Collection<?> c): Removes all of this collection's elements that are also contained in the specified
collection (optional operation).
7) retainAll(Collection<?> c): Retains only the elements in this collection that are contained in the specified
collection (optional operation).
8)toArray(): Returns an array containing all of the elements in this collection.
9)toArray(T[] a): Returns an array containing all of the elements in this collection; the runtime type of the
returned array is that of the specified array.
10)toString(): Returns a string representation of this collection.
    Methods Inherited From Interface java.util.Collection
1)parallelStream(): Returns a possibly parallel Stream with this collection as its source.
2)removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that
satisfy the given predicate.
3)stream(): Returns a sequential Stream with this collection as its source.
4)toArray(IntFunction<T[]> generator): Returns an array containing all of the elements in this collection,
using the provided generator function to allocate the returned array.
    Methods Inherited From Interface java.lang.Iterable
1)forEach(Consumer<? super T> action): Performs the given action for each element of the Iterable until all elements
have been processed or the action throws an exception.
    Methods Inherited From Interface java.util.List
1)addAll(Collection<? extends E> c): Appends all of the elements in the specified collection to the end of this list,
in the order that they are returned by the specified collection's iterator (optional operation).
2)contains(Object o): Returns true if this list contains the specified element.
3)containsAll(Collection<?> c): Returns true if this list contains all of the elements of the specified collection.
4)isEmpty(): Returns true if this list contains no elements.
5)remove(Object o): Removes the first occurrence of the specified element from this list,
if it is present (optional operation).
6)removeAll(Collection<?> c): Removes from this list all of its elements that are contained in the specified
collection (optional operation).
7)replaceAll(UnaryOperator<E> operator): Replaces each element of this list with the result of
applying the operator to that element.
8)retainAll(Collection<?> c): Retains only the elements in this list that are contained in the specified
collection (optional operation).
9)size(): Returns the number of elements in this list.
10)sort(Comparator<? super E> c): Sorts this list according to the order induced by the specified Comparator.
11)spliterator(): Creates a Spliterator over the elements in this list.
12)toArray(): Returns an array containing all of the elements in this list in
proper sequence (from first to last element).
13)toArray(T[] a): Returns an array containing all of the elements in this list in proper sequence
(from first to last element); the runtime type of the returned array is that of the specified array.
The AbstractSequentialList class in Java is a subclass of AbstractList that provides a skeletal
implementation of the List interface, specifically for lists that allow sequential access to their elements.
This means that elements can be accessed in a predictable order, such as first to last.
By extending the AbstractSequentialList class, you only need to implement the listIterator and size methods
which provides a basic implementation of a sequential list.
This can save you a lot of time and code compared to implementing the List interface from scratch.
    Advantages of using AbstractSequentialList in Java
1.Reduced code duplication
2.Consistent behavior
    Disadvantages of using AbstractSequentialList in Java
1.Limited functionality
2.Increased complexity

    Set Interface
It represents a collection of unique elements, meaning it does not allow duplicate values.
    Key Features of Set
1.Set does not allow duplicate elements; each item must be unique
2.Elements in a Set are not stored or retrieved in any defined order.
3.LinkedHashSet maintains insertion order, while TreeSet keeps elements sorted.
4.Most Set implementations allow only a single null element.
5.Set supports standard methods like add(), remove(), contains(), size() and iterator() from the Collection interface.
    Creating Set Objects
Since Set is an interface, objects cannot be created of the typeset.
We always need a class that extends this list in order to create an object.
After the introduction of Generics,
it is possible to restrict the type of object that can be stored in the Set.
This type-safe set can be defined as:
    // Obj is the type of the object to be stored in Set
    Set<Obj> set = new HashSet<Obj> ();
Set interface provides commonly used operations to manage unique elements in a collection.
These include:
1.Adding elements
2.Accessing elements
3.Removing elements
4.Iterating elements
    Classes that implement the Set interface
1. HashSet: This is a collection class that implements a hash table-based Set,
storing elements based on their hashcode without maintaining insertion order and allowing one null element.
2. EnumSet: This is a specialized Set implementation for use with enum types
It is part of the Java Collections Framework and offers high performance, often faster than HashSet.
All elements in an EnumSet must belong to the same enum type, defined at creation time.
3. LinkedHashSet: This is an ordered version of HashSet that maintains insertion order,
using a doubly-linked list across all elements.
4. TreeSet: This is a SortedSet implementation that stores elements in ascending order using a tree structure,
ensuring natural ordering or a custom comparator.
    Methods of Set Interface
1)add(element): Adds element if not already present. Returns true if added.
2)addAll(collection): Adds all elements from the given collection.
3)clear(): Removes all elements from the set.
4))contains(element): Checks if the set contains the specified element.
5)containsAll(collection): Checks if the set contains all elements from the given collection.
6)hashCode(): Returns the hash code of the set.
7)isEmpty(): This method is used to check whether the set is empty or not.
8)iterator(): This method is used to return the iterator of the set.
9)remove(element): Removes the specified element from the set.
10)removeAll(collection): Removes all elements in the given collection from the set.
11)retainAll(collection): Retains only elements present in the given collection.
12)size(): Returns the number of elements in the set.
13)toArray(): This method is used to form an array of the same elements as that of the Set.
    HashSet
HashSet in Java implements the Set interface of Collections Framework.
It is used to store the unique elements and it doesn't maintain any specific order of elements.
-Can store the Null values.
-Uses HashMap (implementation of hash table data structure) internally.
-Also implements Serializable and Cloneable interfaces.
-HashSet is not thread-safe. So to make it thread-safe, synchronization is needed externally.
    Capacity of HashSet
Capacity refers to the number of buckets in the hash table.
The default capacity of a HashSet is 16, and the load factor is 0.75.
When the number of elements exceeds the capacity automatically increases (resizes) to maintain performance.
    new capacity = old capacity × 2
Load Factor
Load Factor is a measure that controls how full the HashSet can get before resizing.
Default Load Factor = 0.75. If the number of elements exceeds the threshold, the capacity is doubled.
    Threshold = capacity × load factor
Constructors of HashSet class
To create a HashSet, we need to create an object of the HashSet class.
The HashSet class consists of various constructors that allow the possible creation of the HashSet.
The following are the constructors available in this class.
1. HashSet()
Creates a new empty HashSet with default capacity (16) and load factor (0.75).
syntax
 HashSet<Type> set = new HashSet<>();
2. HashSet(int initialCapacity)
Creates an empty HashSet with the specified initial capacity and default load factor (0.75).
Syntax:
HashSet<Type> set = new HashSet<>(int initialCapacity);
3. HashSet(int initialCapacity, float loadFactor)
Creates an empty HashSet with the given initial capacity and load factor.
Syntax:
HashSet<Type> set = new HashSet<>(int initialCapacity, float loadFactor);
4. HashSet(Collection<? extends E> c)
Creates a new HashSet containing the elements of the specified collection (removes duplicates automatically).
syntax
HashSet<Type> set = new HashSet<>(Collection);
    Performing Various Operations on HashSet
1. Adding Elements in HashSet
To add an element to the HashSet, we can use the add() method.
duplicate elements are not allowed
insertion order is not retained
2. Removing Elements in HashSet
The values can be removed from the HashSet using the remove() method.
3. Iterating through the HashSet
Iterate through the elements of HashSet using the iterator() method
    Methods of HashSet
1)add(E e): Used to add the specified element if it is not present, if it is present then return false.
2)clear(): Used to remove all the elements from the set.
3)contains(Object o): Used to return true if an element is present in a set.
4)remove(Object o): Used to remove the element if it is present in set.
5)iterator(): Used to return an iterator over the element in the set.
6)isEmpty(): Used to check whether the set is empty or not.
Returns true for empty and false for a non-empty condition for set.
7)size(): Used to return the size of the set.
8)clone(): Used to create a shallow copy of the set.
    Differences between HashSet and HashMap.
HashSet                                                 HashMap
1)HashSet implements a Set interface.                   HashMap implements a storesMap interface.
2)HashSet doesn't allow duplicate values.               HashMap stores key-value pairs and doesn’t allow duplicate keys.
                                                        A duplicate key replaces the old value.
3)HashSet requires only one object add(Object o).       HashMap requires two objects put(K key, V Value) to add an element to the HashMap object.
4)HashSet internally uses a HashMap, where each         HashMap does not have any concept of dummy value.
element added is stored as a key with a dummy value.
5)HashSet internally uses the HashMap object to         HashMap internally uses hashing to store or add objects
store or add the objects.
6)HashSet is slower than HashMap.                       HashMap is faster than HashSet.
7)HashSet uses the add() method for adding              HashMap uses the put() method for storing data.
or storing data.
    Traverse through a HashSet in Java
Below are few ways with which we can iterate over elements to perform any kind of operations o
1.Using for-each loop
2.Using forEach method
Stream forEach(Consumer action) performs an action for each element of the stream.
it may traverse the stream to produce a result or a side-effect.
3.Using Iterators
    How to Get Random Elements from Java HashSet?
which can be done by either of the two ways:
1.By converting it to an array
-Firstly convert HashSet into an array and then access the random element from it.
-Then we will create an object of Random class and will call the nextInt() method of that class
which will give us any random number less than or equal to the size of the HashSet.
-And then using an array we will simply print the element present at that index.
2.Using an Iterator or a for loop
-In order to get random elements from the HashSet object,
we need to generate a random number between 0 (inclusive) and the size of the HashSet (exclusive).
-And then iterate through the set till we reach the element located at the random number position as given below.
-In this approach, we will get the element at a random index using an Iterator.
    How to Find the Minimum and Maximum Value from Java HashSet?
There are a couple of ways to find the maximum and minimum from the HashSet in Java.
1.Using Collection class
Using Collections class in Java we can find maximum and minimum
value with the help of max() and min() method of Collections class.
2.Using simple iteration
    How to sort HashSet in Java
The elements of the HashSet can be sorted indirectly by converting into List or TreeSet
    How to convert List to HashSet
The List interface provides a way to store the ordered collection.
The ways to convert List to HashSet :
1.Passing List Object as parameter in HashSet.
2.Adding each element of List into HashSet using loop.
3.Using addAll() Method of Set class.
4.Using stream in Java
Note: Stream only works in Java8 or versions above it.
We use stream in java to convert the given list to stream, then stream to set.
    How to convert Array to HashSet in Java
1)Brute Force or Naive Method
-Create an empty set.
-Iterate the elements of the array and add one by one to the set.
2)Using Java 8 Stream API
-Get the Array to be converted.
-Convert the array to Stream.
-Convert the Stream to Set using Collectors.toSet().
-Collect the formed set using the collect() method.
-Return the formed Set.

    AbstractSet
In Java, the AbstractSet class is part of the Java Collections Framework.
It provides a Skeleton implementation of the set interface.
which is a collection that does not allow duplicate elements
This class is abstract, meaning it cannot be instantiated directly,
but it can be extended to create a custom set implementation
-AbstractSet implements the set interface but does not provide a full implementation of all set methods.
-It provides implementations for methods like size(), isEmpty() and contains()
-It requires subclasses to implement the iterator()method to define how elements are iterated over.
    AbstractSet Class Hierarchy
AbstractSet implements Iterable<E>, Collection<E>, Set<E> interfaces.
The direct subclasses are
CopyOnWriteArraySet, EnumSet, HashSet, TreeSet.
    Declaration of AbstractSet Class
public abstract class AbstractSet<E> extends AbstractCollection<E> implements Set<E>
    Constructor
protected AbstractSet()
This Constructor is used to prevent direct instantiation of the AbstractSet class,
allowing only its subclasses to be instantiated.
    Performing Various Operations on AbstractSet
1. Adding elements
We can use add() method to insert element to a AbstractSet class.
2. Removing Elements
We can use various methods like remove(), removeAll(),
retainAll() and clear() method to remove elements from the AbstractSet.
3.Iterating Elements
We can use the iterator() method to iterate over the elements of a AbstractSet.
    Methods
1.equals(Object o): Compares the specified object with this set for equality.
2.hashCode(): Returns the hash code value for this set.
3.removeAll(Collection<?> c): Removes from this set all of its elements that are contained in the specified collection (optional operation).
    Methods Declared in Class java.util.AbstractCollection
1.add(E e): Ensures that this collection contains the specified element.
2.addAll(Collection<? extends E> c):Adds all of the elements in the specified collection to this collection.
3.clear(): Removes all of the elements from this collection.
4.contains(Object o): Returns true if this collection contains the specified element.
5.containsAll(Collection<?> c): Returns true if this collection contains all of the elements in the specified collection.
6.isEmpty(): Returns true if this collection contains no elements.
7.iterator(): Returns an iterator over the elements contained in this collection.
8.remove(Object o): Removes a single instance of the specified element from this collection, if it is present.
9.retainAll(Collection<?> c): Retains only the elements in this collection that are contained in the specified collection.
10.toArray(): Returns an array containing all of the elements in this collection.
11.toArray(T[] a): Returns an array containing all of the elements in this collection.
12.toString(): Returns a string representation of this collection.
    Methods Declared in Interface java.util.Collection
1.parallelStream(): Returns a possibly parallel Stream with this collection as its source.
2.removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that satisfy the given predicate.
3.stream(): Returns a sequential Stream with this collection as its source.
4.toArray(IntFunction<T[]> generator): Returns an array containing all of the elements in this collection,
using the provided generator function to allocate the returned array.
    Methods Declared in interface java.lang.Iterable
1.forEach(Consumer<? super T> action): Performs the given action for each element of the Iterable until all elements
have been processed or the action throws an exception.
    Methods Declared in interface java.util.Set
1.add(E e)
2.addAll(Collection<? extends E> c)
3.clear()
4.contains(Object o)
5.containsAll(Collection<?> c)
6.isEmpty()
7.iterator()
8.remove(Object o)
9.retainAll(Collection<?> c)
10.size()
11.spliterator()
12.toArray()
13.toArray(T[] a)
    Characteristics of AbstractSet
-Implements the Set interface
-Implements some set methods
-Supports iterator
-Does not implement all set methods
-Provides default implementations
-Supports null elements
-Unordered
-Thread-unsafe

    CopyOnWriteArraySet
This is the part of the java.util.concurrent package and
used to handle thread-safe operations in multi-threaded environments.
-CopyOnWriteArraySet uses a CopyOnWriteArrayList internally.
-Iterators can only perform read operations.
-CopyOnWriteArraySet is Ideal for small sets where read operations are much more frequent than modifications.
-Multiple threads can perform updates simultaneously,
only one thread can iterate the set at a time without encountering ConcurrentModificationException.
-CopyOnWriteArraySet is a class that implements the Set interface.
    Concurrency
Concurrency in Java refers to the ability to execute multiple tasks or parts of a program seemingly simultaneously
    Constructors
1.CopyOnWriteArraySet(): Creates an empty set.
2.CopyOnWriteArraySet(Collection c): Creates a set containing all of the elements of the specified collection.
    Methods
1.add(E e): Adds the specified element to this set if it is not already present.
2.addAll(Collection<? extends E> c): Adds all of the elements in the specified collection to this set if they’re not already present.
3.clear(): Removes all of the elements from this set.
4.contains(Object o): Returns true if this set contains the specified element.
5.containsAll(Collection<?> c): Returns true if this set contains all of the elements of the specified collection.
6.equals(Object o):Compares the specified object with this set for equality.
7.forEach(Consumer<? super E> action): Performs the given action for each element of the Iterable until all elements
have been processed or the action throws an exception.
8.isEmpty(): Returns true if this set contains no elements.
9.iterator(): Returns an iterator over the elements contained in this set in the order in which these elements were added.
10.remove(Object o): Removes the specified element from this set if it is present.
11.removeAll(Collection<?> c): Removes from this set all of its elements that are contained in the specified collection.
12.removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that satisfy the given predicate.
13.retainAll(Collection<?> c): Retains only the elements in this set that are contained in the specified collection.
14.size(): Returns the number of elements in this set.
15.spliterator(): Returns a Spliterator over the elements in this set in the order in which these elements were added.
16.toArray(): Returns an array containing all of the elements in this set.
17.toArray(T[] a): Returns an array containing all of the elements in this set;
the runtime type of the returned array is that of the specified array.
    HashSet                                                                 CopyOnWriteArraySet
1.It belongs to java.util package                                          It belongs to java.util.concurrent package
2.HashSet is not synchronized, meaning it’s not thread-safe.               CopyOnWriteArraySet is synchronized and thread-safe.

    LinkedHashSet
This is very similar to a HashSet.
It combines the functionality of a HashSet with a LinkedList to maintain the insertion order of elements.
-Stores unique elements only.
-Maintains insertion order.
-Provides faster iteration compared to HashSet.
-Allows null elements.
LinkedHashSet maintains insertion order using a doubly-linked list.
Unlike HashSet, it allows predictable iteration in the order elements were added.
    Constructors of LinkedHashSet
1.LinkedHashSet()
This constructor is used to create an empty LinkedHashSet
with the default capacity i.e. 16 and load factor 0.75.
2.LinkedHashSet(Collection C)
Used in initializing the HashSet with the elements of the collection C.
3. LinkedHashSet(int size):
Used to initialize the size of the LinkedHashSet with the integer mentioned in the parameter.
4. LinkedHashSet(int capacity, float fillRatio)
    Performing Various Operations on LinkedHashSet
1.Adding Elements in LinkedHashSet
In order to add an element to the LinkedHashSet, we can use the add()
2.Removing Elements in LinkedHashSet
The values can be removed from the LinkedHashSet using the remove() method.
3.Iterating through the LinkedHashSet
Iterate through the elements of  LinkedHashSet using the iterator() method.
    Advantages of LinkedHashSet
-It maintains insertion order.
-It allows quick insertion, deletion and lookup of elements.
-It is useful for caching applications where insertion order is important.
    Disadvantages of LinkedHashSet
-It takes higher memory as compared to HashSet due to the linked list for maintaining insertion order.
-This is slightly slower operations compared to HashSet because of the linked structure.
    Methods of LinkedHashSet
1.add(E e): Adds an element if it’s not already present.
2.addAll(Collection c): Adds all elements from the specified collection.
3.clear(): Removes all elements from the set.
4.contains(Object o): Checks if the set contains the specified element.
5.containsAll(Collection c): Checks if the set contains all elements from the given collection.
6.remove(Object o): Removes the specified element from the set.
7.removeAll(Collection c): Removes all matching elements from the set.
8.retainAll(Collection c): Keeps only elements present in the given collection.
9.isEmpty(): Checks if the set is empty.
10.size(): Returns the number of elements in the set.
11.iterator(): Returns an iterator over the elements.
12.toArray(): Returns an array containing all elements.
13.toArray(T[] a): Returns an array of the specified type containing all elements.
14.hashCode(): Returns hash code of the set.
15.equals(Object o): Compares this set with another set.
16.clone(): Creates a shallow copy of the set.
17.toString(): Returns a string representation of the set.
18.spliterator(): Returns a Spliterator for this set.
19.stream(): Returns a sequential stream of elements.
20.parallelStream(): Returns a parallel stream of elements.
21.removeIf(Predicate filter): Removes elements that match a condition.
22.forEach(Consumer action): Performs an action on each element.
    Accessing LinkedHashSet elements by Index
Methods:
1.A naive approach using the iteration count method
-Use iterator to traverse to our LinkedHashSet
-Initiate out index pointer currentindex = 0
-Start the iteration using a while loop and if the current
index becomes equal to the given index print the element.
2.Converting LinkedHashSet to Array
-Convert given LinkedHashSet to Array using toArray() method.
-Accessing the element on the given index in the array.
3.Converting LinkedHashSet to List
-Convert our LinkedHashSet to List like ArrayList.
-Using get() method to get an element in a given index.
    Removing elements from a LinkedHashSet
The remove(Object O) method is used to remove a particular element from a LinkedHashSet
This method returns True if the specified element is present in the LinkedHashSet otherwise it returns False.
    Union of Sets in LinkedHashSets
Use the addAll() method to merge two LinkedHashSet objects or
append elements of one LinkedHashSet object to another LinkedHashSet object
-The addAll method adds all the elements of the specified collection to this set object.
    Difference Between LinkedHashSet, TreeSet, and HashSet
-when to use
HashSet
If you don’t want to maintain insertion order but want to store unique objects
LinkedHashSet
If you want to maintain the insertion order of elements then you can use LinkedHashSet
TreeSet
If you want to sort the elements according to some Comparator then use TreeSet

    EnumSet
EnumSet is a specialized set implementation for use with enum types
-It extends the AbstractSet class and implements the Set Interface in Java.
-The EnumSet class is a member of the Java Collections Framework and is not synchronized.
-All of the elements in an EnumSet must come from a single enumeration type
-It does not allow null Objects
-It uses a fail-safe iterator,
    Declaration of EnumSet
In Java, the declaration of EnumSet can be done as
EnumSet<Type> variableName = EnumSet.of(Element1, Element2, Element3);
    Methods
1.allOf(Class<E> elementType): Creates an enum set containing all of the elements in the specified element type.
2.clone(): Returns a copy of this set.
3.complementOf(EnumSet<E> s): Creates an enum set with the same element type as the specified enum set.
4.copyOf(Collection<E> c): Creates an enum set initialized from the specified collection.
5.copyOf(EnumSet<E> s): Creates an enum set with the same element type as the specified enum set.
6.noneOf(Class<E> elementType): Creates an empty enum set with the specified element type.
7.of(E e): Creates an enum set initially containing the specified element.
8.of(E e1, E e2): Creates an enum set initially containing the specified elements.
9.of(E first, E… rest): Creates an enum set initially containing the specified elements.
10.range(E from, E to): Creates an enum set initially containing all of the elements in the range
defined by the two specified endpoints.
    Creating a EnumSet
EnumSet is an abstract class, we can not directly create an instance of it.
EnumSet is an abstract class, we can not directly create an instance of it.
1.RegularEnumSet:
It uses a single long object to store the elements of the EnumSet
-RegularEnumSet can store up to 64 enum values.
2.JumboEnumSet
It uses an array of long values to store the elements of the EnumSet.
The key difference is that JumboEnumSet allows storing more than 63 values
by using multiple long elements to represent a larger set of enum constants.
    Performing Various Operations on EnumSet
1.Adding Elements
We can use add() and addAll() to insert elements to an EnumSet.
2. Accessing Elements
We can access the EnumSet using the iterator() method.
3. Removing Elements
We can use the remove() and removeAll() to remove elements from an EnumSet.
    Methods Declared in Class java.util.AbstractSet
1.equals(Object): Compares the specified object with this set for equality.
2.hashCode(): Returns the hash code value for this set.
3.removeAll(Collection<?> c): Removes from this set all of its elements that are contained in the specified collection.
    Methods Declared in Interface java.util.Collection
1.parallelStream(): Returns a possibly parallel Stream with this collection as its source.
2.removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that satisfy the given predicate.
3.stream(): Returns a sequential Stream with this collection as its source.
4.toArray(IntFunction<T[]> generator): Returns an array containing all of the elements in this collection,
using the provided generator function to allocate the returned array.
    Methods Declared in Interface java.lang.Iterable
1.forEach(Consumer<? super T> action): Performs the given action for each element of the Iterable until
all elements have been processed or the action throws an exception.
    Methods Declared in Interface java.util.Set
1.add(E e): Adds the specified element to this set if it is not already present (optional operation).
2.addAll(Collection<? extends E> c): Adds the specified element to this set if it is not already present.
3.clear(): Removes all of the elements from this set.
4.contains(Object o): Returns true if this set contains the specified element.
5.containsAll(Collection<?> c): Returns true if this set contains all of the elements of the specified collection.
6.isEmpty(): Returns true if this set contains no elements.
7.iterator(): Returns an iterator over the elements in this set.
8.remove(Object o): Removes the specified element from this set if it is present.
9.retainAll(Collection<?> c): Retains only the elements in this set that are contained in the specified collection.
10.size(): Returns the number of elements in this set.
11.spliterator(): Creates a Spliterator over the elements in this set.
12.toArray(): Returns an array containing all of the elements in this set.
    Methods Declared in Class java.util.AbstractCollection
1.add(E e): Ensures that this collection contains the specified element.
2.addAll(Collection<? extends E> c): Adds all of the elements in the specified collection to this collection
3.clear(): Removes all of the elements from this collection
4.contains(Object o): Returns true if this collection contains the specified element.
5.containsAll(Collection<?> c): Returns true if this collection contains all of the elements in the specified collection.
6.isEmpty(): Returns true if this collection contains no elements.
7.iterator(): Returns an iterator over the elements contained in this collection.
8.remove(Object o); Removes a single instance of the specified element from this collection, if it is present.
9.retainAll(Collection<?> c): Retains only the elements in this collection that are contained in the specified collection .
10.toArray(): Returns an array containing all of the elements in this collection.
11.toArray(T[] a): Returns an array containing all of the elements in this collection; the runtime type of the
returned array is that of the specified array.
12. toString(): Returns a string representation of this collection.

    SortedSet Interface
This interface contains the methods inherited from the Set interface
and adds a feature that stores all the elements in this interface to be stored in a sorted manner.
    1.TreeSet
A TreeSet is a collection class that stores unique elements in a sorted order.
In this set The ordering of the elements is maintained by a set using their natural ordering.
The class which implements the navigable set is a TreeSet which is an implementation of a self-balancing tree.
    Key Features of TreeSet
-duplicate insertions are ignored.
-TreeSet does not allow null values.
-Implements the NavigableSet interface and provides navigation methods like higher(), lower(), ceiling() and floor().
-Not thread-safe
    Constructors of TreeSet
In order to create a TreeSet, we need to create an object of the TreeSet class.
The following are the constructors available in this class
1.TreeSet()
Creates an empty TreeSet that sorts elements in their natural order.
    TreeSet ts = new TreeSet();
2.TreeSet(Comparator)
This constructor is used to build an empty TreeSet object in which elements will need an external
specification of the sorting order.
    TreeSet ts = new TreeSet(Comparator comp);
3.TreeSet(Collection)
This constructor is used to build a TreeSet object containing all the elements from the given collection
in which elements will get stored in default natural sorting order
    TreeSet t = new TreeSet(Collection col);
4.TreeSet(SortedSet)
Creates a TreeSet containing the same elements and order as the specified SortedSet.
    TreeSet t = new TreeSet(SortedSet s);
    Various Operations over TreeSet
1. Adding Elements
To add elements to a TreeSet, use the add() method.
2. Accessing the Elements
After adding the elements, if we wish to access the elements,
we can use inbuilt methods like contains(), first(), last(), etc.
3. Removing the Values
The values can be removed from the TreeSet using the remove() method.
4.Iterating the TreeSet
5.StringBuffer
StringBuffer does NOT implement the Comparable interface.
Therefore, you must provide a custom Comparator to use StringBuffer objects in a TreeSet.
  Methods of TreeSet
1.add(Object o): Adds element in sorted order; ignores duplicates.
2.addAll(Collection c): Adds all elements from a collection; ignores duplicates.
3.ceiling?(E e): This method returns the least element in this set greater than or equal to
the given element, or null if there is no such element.
4.clear(): This method will remove all the elements.
5.clone(): The method is used to return a shallow copy of the set, which is just a simple copied set.
6.Comparator(): This method will return the Comparator used to sort elements in TreeSet.
7.contains(Object o): This method will return true if a given element is present in TreeSet else it will return false.
8.descendingIterator?(): This method returns an iterator over the elements in this set in descending order.
9.descendingSet?(): This method returns a reverse order view of the elements contained in this set.
10.first(): This method will return the first element in TreeSet if TreeSet is not null else it will throw NoSuchElementException.
11.floor?(E e): This method returns the greatest element in this set less than or equal to the given element,
or null if there is no such element.
12.headSet(Object toElement): This method will return elements of TreeSet which are less than the specified element.
13.higher?(E e): This method returns the least element in this set strictly greater than the given element,
or null if there is no such element.
14.isEmpty(): This method is used to return true if this set contains no elements or is empty and false for the opposite case.
15.iterator(): Returns an iterator for iterating over the elements of the set.
16.last(): This method will return the last element in TreeSet if TreeSet is not null else it will throw NoSuchElementException.
17.lower?(E e): This method returns the greatest element in this set strictly less than the given element,
or null if there is no such element.
18.pollFirst?(): This method retrieves and removes the first (lowest) element, or returns null if this set is empty.
19.pollLast?(): This method retrieves and removes the last (highest) element, or returns null if this set is empty.
20.remove(Object o): This method is used to return a specific element from the set.
21.size(): This method is used to return the size of the set or the number of elements present in the set.
22.spliterator(): This method creates a late-binding and fail-fast Spliterator over the elements in this set.
23.subSet(Object fromElement, Object toElement): This method will return elements ranging from fromElement to toElement.
24.tailSet(Object fromElement)	This method will return elements of TreeSet which are greater than or equal to the specified element.
    Difference Between EnumSet and TreeSet in Java
-EnumSet is a specialized implementation of the Set interface for enumeration types.
-TreeSet is a class that implementation the SortedSet interface in Java.
    How to Create a TreeSet with a List in Java?
TreeSet can be created from List by passing the List to the TreeSet constructor in Java
we can traverse complete List and adding each element of the List to the TreeSet.
Approach 1:
-Create a List object.
-Enter multiple inputs in the List.
-Create a TreeSet Object.
-Initialize object with a constructor and pass List object in it.
-Print the Treeset.
Approach 2:
-Create a List object.
-Enter multiple inputs in the List.
-Create a TreeSet Object.
-Start List traversal and add that element in the TreeSet.
-After complete traversal, Print the Treeset.
Approach 3
-Initialize and Declare the List object with inputs.
-Now, Create the TreeSet object.
-Collections.addAll() is used to add all elements from one object to another object.
-Print the TreeSet.
    How to Remove Duplicate Entries from an Array using TreeSet
Approach: add() method of Set
    Getting Least Value Element From a Set by Using Sorting Logic on TreeSet in Java
Approach
-Use comparators to order the object of a user-defined class.
-Implementing the sorting functionality that overrides the compare() method to sort the TreeSet by value.
-After sorting, the first object of the TreeSet will be the least value element.

    2.NavigableSet
The NavigableSet is a subtype of the SortedSet interface.
It provides methods to navigate through the elements in the set.
The classes that implement the NavigableSet interface are TreeSet and ConcurrentSkipListSet.
-It allows you to navigate in both directions ascending and descending order
-The most common implementation of NavigableSet is TreeSet.
    Declaration of NavigableSet
NavigableSet<Type> setName;
    Creating NavigableSet Objects
We can not create a NavigableSet directly since it's an interface.
Instead we use a class like TreeSet that implements it.
NavigableSet<Obj> set = new TreeSet<Obj>();
    Performing Various Operations on NavigableSet
1. Adding Elements
We can use the add() method to insert elements to the NavigableSet.
2. Accessing Elements
We can use inbuilt methods like contains(), first(), last(), etc.
3. Removing Elements
The values can be removed from the NavigableSet using the remove(), pollFirst(), pollLast().
4. Iterating Elements
There are various ways to iterate through the NavigableSet.
The most famous one is to use the enhanced for loop.
    Methods
1.ceiling(E e): Returns the least element in this set greater than or equal to the given element,
or null if there is no such element.
2.descendingIterator(): Returns an iterator over the elements in this set, in descending order.
3.descendingSet(): Returns a reverse order view of the elements contained in this set.
4.floor(E e): Returns the greatest element in this set less than or equal to the given element,
or null if there is no such element.
5.headSet(E toElement): Returns a view of the portion of this set whose elements are strictly less than toElement.
6.headSet(E toElement, boolean inclusive): Returns a view of the portion of this set whose elements are less than
(or equal to, if inclusive is true) toElement.
7.higher(E e): Returns the least element in this set strictly greater than the given element,
or null if there is no such element.
8.iterator(): Returns an iterator over the elements in this set, in ascending order.
9.lower(E e): Returns the greatest element in this set strictly less than the given element,
or null if there is no such element.
10.pollFirst(): Retrieves and removes the first (lowest) element, or returns null if this set is empty.
11.pollLast(): Retrieves and removes the last (highest) element, or returns null if this set is empty.
12.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive): Returns a view of the portion of
this set whose elements range from fromElement to toElement.
13.subSet(E fromElement, E toElement): Returns a view of the portion of this set whose elements range from fromElement,
inclusive, to toElement, exclusive.
14.tailSet(E fromElement): Returns a view of the portion of this set whose elements
are greater than or equal to fromElement.
15.tailSet(E fromElement, boolean inclusive): Returns a view of the portion of this set whose elements are
greater than (or equal to, if inclusive is true) fromElement.
    Methods Inherited from Interface java.util.SortedSet
1.comparator(): This method returns the comparator used to order the elements in this set,
or null if this set uses the natural ordering of its elements.
2.first(): This method returns the first(lowest) element present in this set.
3.last(): This method returns the last(highest) element present in the set.
4.spliterator(): Creates a Spliterator over the elements in this sorted set.
    Methods Inherited from Interface java.util.Set
1.add(element): This method is used to add a specific element to the set.
2.addAll(collection): This method is used to append all of the elements from the
mentioned collection to the existing set.
3.clear(): This method is used to remove all the elements from the set but not delete the set.
4.contains(element): This method is used to check whether a specific element is present in the Set or not.
5.containsAll(collection): This method is used to check whether the set contains all the elements
present in the given collection or not.
6.equals(): Compares the specified object with this set for equality.
7.hashCode(): This method is used to get the hashCode value for this instance of the Set.
8.isEmpty(): This method is used to check if a NavigableSet is empty or not.
9.remove(element): This method is used to remove the given element from the set.
10.removeAll(collection): This method is used to remove all the elements from the collection
which are present in the set.
11.retainAll(collection): This method is used to retain all the elements from the set which are
mentioned in the given collection.
12.size(): This method is used to get the size of the set.
13.toArray(): This method is used to form an array of the same elements as that of the Set.
14.toArray(T[] a): Returns an array containing all of the elements in this set.
    Methods Declared in Interface java.util.Collection
1.parallelStream(): Returns a possibly parallel Stream with this collection as its source.
2.removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that satisfy the given predicate.
3.stream(): Returns a sequential Stream with this collection as its source.
4.toArray?(IntFunction<T[]> generator): Returns an array containing all of the elements in this collection, using the
 provided generator function to allocate the returned array.
    Methods Declared in Interface java.lang.Iterable
1)forEach(Consumer<? super T> action): Performs the given action for each element of the Iterable until all elements
have been processed or the action throws an exception.

    3. ConcurrentSkipListSet
The ConcurrentSkipListSet is the part of the java.util.concurrent package.
and it provides a scalable, thread-safe alternative to TreeSet.
It is a sorted set that lets multiple threads safely access and modify the set at the same time without causing issues.
-It is thread-safe.
-Elements are in sorted order, and it supports navigable set operations (e.g., floor, ceiling, higher, lower).
    Declaration of ConcurrentSkipListSet
ConcurrentSkipListSet<Type> set = new ConcurrentSkipListSet<>();
    Constructors
1.ConcurrentSkipListSet(): It is used to construct an empty set.
2.ConcurrentSkipListSet(Collection<E> c): It is used to construct a set with the elements of the
Collection passed as the parameter.
3.ConcurrentSkipListSet(Comparator<E> comparator)
It is sed to construct a new, empty set that orders its elements according to the specified comparator.
4.ConcurrentSkipListSet(SortedSet<E> s)
It is used to construct a new set containing the same elements and using the same ordering as the specified sorted set.
    methods
1.add(E e): Adds the specified element to this set if it is not already present.
2.ceiling(E e): Returns the least element in this set greater than or equal to the given element,
or null if there is no such element.
3.clear(): Removes all of the elements from this set.
4.clone(): Returns a shallow copy of this ConcurrentSkipListSet instance.
5.comparator(): Returns the comparator used to order the elements in this set,
or null if this set uses the natural ordering of its elements.
6.contains(Object o): Returns true if this set contains the specified element.
7.descendingIterator(): Returns an iterator over the elements in this set in descending order.
8.descendingSet(): Returns a reverse order view of the elements contained in this set.
9.equals(Object o): Compares the specified object with this set for equality.
10.first(): Returns the first (lowest) element currently in this set.
11.floor(E e): Returns the greatest element in this set less than or equal to the given element,
or null if there is no such element.
12.headSet(E toElement): Returns a view of the portion of this set whose elements are strictly less than toElement.
13.headSet(E toElement, boolean inclusive):
Returns a view of the portion of this set whose elements are less than (or equal to, if inclusive is true) toElement.
14.higher(E e): Returns the least element in this set strictly greater than the given element, or null if there is no such element.
15.isEmpty(): Returns an iterator over the elements in this set in ascending order.
16.last(): Returns the last (highest) element currently in this set.
17.lower(E e): Returns the greatest element in this set strictly less than the given element, or null if there is no such element.
18.pollFirst(): Retrieves and removes the first (lowest) element, or returns null if this set is empty.
19.pollLast(): Retrieves and removes the last (highest) element, or returns null if this set is empty.
20.remove(Object o): Removes the specified element from this set if it is present.
21.removeAll(Collection<?> c): Removes from this set all of its elements that are contained in the specified collection.
22.size(): Returns the number of elements in this set.
23.spliterator(): Returns a Spliterator over the elements in this set.
24.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
Returns a view of the portion of this set whose elements range from fromElement to toElement.
25.subSet(E fromElement, E toElement): Returns a view of the portion of this set whose elements range from fromElement,
inclusive, to toElement, exclusive.
26.tailSet(E fromElement): Returns a view of the portion of this set whose elements are greater than or equal to fromElement.
    Method Inherited from Class java.util.AbstractSet
1.hashCode(): Returns the hash code value for this set.
    Methods Inherited from Class java.util.AbstractCollection
1.addAll(Collection<? extends E> c): Adds all of the elements in the specified collection to this collection.
2.containsAll(Collection<?> c): Returns true if this collection contains all of the elements in the specified collection.
3.retainAll(Collection<?> c): Retains only the elements in this collection that are contained in the specified collection.
4.toArray(): Returns an array containing all of the elements in this collection.
5.toArray(T[] a): Returns an array containing all of the elements in this collection.
6.toString(): Returns a string representation of this collection.
    Methods Inherited from Interface java.util.Set
1.addAll(Collection<? extends E> c): Adds all of the elements in the specified collection to this set if they're not already present.
2.containsAll(Collection<?> c): Returns true if this set contains all of the elements of the specified collection.
3.hashCode(): Returns the hash code value for this set.
4.retainAll(Collection<?> c): Retains only the elements in this set that are contained in the specified collection.
5.toArray(): Returns an array containing all of the elements in this set.
6.toArray(T[] a): Returns an array containing all of the elements in this set.
    Methods Inherited from Interface java.util.Collection
1.parallelStream(): Returns a possibly parallel Stream with this collection as its source.
2.removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that satisfy the given predicate.
3.stream(): Returns a sequential Stream with this collection as its source.
    Method Inherited from Interface java.lang.Iterable
1.forEach(Consumer<? super T> action):
Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception.

    Map Interface
The Map Interface is part of the java.util package and
represents a collection of key-value pairs.
-Keys are unique (no duplicates allowed).
-Each key maps to exactly one value.
-Values can be duplicates.
- Use ConcurrentHashMap for thread-safe operations
    The Map data structure in Java is implemented by two interfaces:
1.Map Interface
2.SortedMap Interface
    The three primary classes that implement these interfaces are
1.HashMap
2.TreeMap
3.LinkedHashMap
    Creating Map Objects
Since Map is an interface, objects cannot be created of the type map.
We always need a class that implements this map interface in order to create an object.
    Operations on Map using HashMap
1.Adding Elements
To add an element to the map, we can use the put() method.
The insertion order is not retained in the hashmap.
2.Changing Element
It can be done by adding the element with the put() method.
The elements in the map are indexed using the keys,
the value of the key can be changed by simply inserting the updated value for the key for which we want to change.
3.Removing Elements
To remove an element from the Map, we can use the remove() method.
4.Iterating through the Map
The most famous way is to use a for-each loop and get the keys.
The value of the key is found by using the getValue() method.
    Methods in Java Map Interface
1.clear(): This method is used in Java Map Interface to clear and remove all of the elements or mappings from a
specified Map collection.
2.containsKey(Object): Checks if a key exists in the map.
3.containsValue(Object): Checks if a value exists in the map.
4.entrySet(): Returns a set view of the map’s key-value pairs.
5.equals(Object): Compares two maps for equality.
6.get(Object): Returns the value for the given key, or null if not found.
7.hashCode(): This method is used in Map Interface to generate a hashCode for the given map containing keys and values.
8.isEmpty(): This method is used to check if a map is having any entry for key and value pairs. If no mapping exists,
then this returns true.
9.keySet(): Returns a set view of the keys in the map.
10.put(Object, Object): This method is used in Java Map Interface to associate the specified value with
the specified key in this map.
11.putAll(Map): This method is used in Map Interface in Java to copy all of the mappings from the specified map to this map.
12.remove(Object): This method is used in Map Interface to remove the mapping for a key from this map if it is present in the map.
13.size(): This method is used to return the number of key/value pairs available in the map.
14.values(): Returns a collection view of the map’s values.
15.getOrDefault(Object key, V defaultValue): Returns the value to which the specified key is mapped,
or defaultValue if this map contains no mapping for the key.
16.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)
If the specified key is not already associated with a value or is associated with null, associate it with the given non-null value.
17.putIfAbsent(K key, V value): Adds a mapping only if the key is not already mapped.

    Hashtable
Hashtable class, introduced as part of the Java Collections framework.
implements a hash table that maps keys to values.
The java.util.Hashtable class is a class in Java that provides a key-value data structure, similar to the Map interface.
-It is similar to HashMap, but is synchronized.
-Hashtable stores key/value pair in hash table.
-In Hashtable we specify an object that is used as a key,
and the value we want to associate to that key.
The key is then hashed, and the resulting hash code is used as the index at which the value is stored within the table.
-The initial default capacity of Hashtable class is 11 whereas loadFactor is 0.75.
- Hashtable provides not fail-fast Enumeration.
In general, it's recommended to use the Map interface or one of its implementations
such as HashMap or ConcurrentHashMap) instead of the Hashtable class.
    HashTable Constructors
In order to create a Hashtable, we need to import it from java.util.Hashtable.
There are various ways in which we can create a Hashtable.
1.Hashtable()
This creates an empty hashtable with the default load factor of 0.75 and an initial capacity is 11.
2.Hashtable(int initialCapacity):
This creates a hash table that has an initial size specified by initialCapacity and the default load factor is 0.75.
3.Hashtable(int size, float fillRatio)
This version creates a hash table that has an initial size specified by size and fill ratio specified by fillRatio.
-fill ratio: Basically,
it determines how full a hash table can be before it is resized upward and its Value lies between 0.0 to 1.0.
4. Hashtable(Map<? extends K,? extends V> m)
This creates a hash table that is initialized with the elements in m.
    Performing Various Operations on Hashtable
1. Adding Elements
In order to add an element to the hashtable, we can use the put() method.
2. Changing Elements
After adding the elements if we wish to change the element,
it can be done by again adding the element with the put() method.
3. Removing Element
In order to remove an element from the Map, we can use the remove() method.
This method takes the key value and removes the mapping for a key from this map if it is present in the map.
    Methods of Hashtable
K – The type of the keys in the map.
V – The type of values mapped in the map.
1.clear(): Clears this hashtable so that it contains no keys.
2.clone(): Creates a shallow copy of this hashtable.
3.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)
Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping).
4.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)
If the specified key is not already associated with a value (or is mapped to null),
attempts to compute its value using the given mapping function and enters it into this map unless null.
5.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)
If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value.
6.contains(Object value): Tests if some key maps into the specified value in this hashtable.
7.containsKey(Object key): Tests if the specified object is a key in this hashtable.
8.containsValue(Object value): Returns true if this hashtable maps one or more keys to this value.
9.elements(): Returns an enumeration of the values in this hashtable.
10.entrySet(): Returns a Set view of the mappings contained in this map.
11.equals(Object o): Compares the specified Object with this Map for equality, as per the definition in the Map interface.
12.get(Object key): Returns the value to which the specified key is mapped,
or null if this map contains no mapping for the key.
13.hashCode(): Returns the hash code value for this Map as per the definition in the Map interface.
14.isEmpty(): Tests if this hashtable maps no keys to values.
15.keys(): Returns an enumeration of the keys in this hashtable.
16.keySet(): Returns a Set view of the keys contained in this map.
17.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)
If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value.
18.put(K key, V value): Maps the specified key to the specified value in this hashtable.
19.putAll(Map<? extends K,? extends V> t)
Copies all of the mappings from the specified map to this hashtable.
20.rehash(): Increases the capacity of and internally reorganizes this hashtable, in order to accommodate
and access its entries more efficiently.
21.remove(Object key): Removes the key (and its corresponding value) from this hashtable.
22.size(): Returns the number of keys in this hashtable.
23.toString(): Returns a string representation of this Hashtable object in the form of a set of entries,
enclosed in braces and separated by the ASCII characters ", " (comma and space).
24.values(): Returns a Collection view of the values contained in this map.
    Methods Declared in interface java.util.Map
1.forEach(BiConsumer<? super K,? super V> action)
Performs the given action for each entry in this map until all entries have been processed or the action throws an exception.
2.getOrDefault(Object key, V defaultValue)
Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key.
3.putIfAbsent(K key, V value)
If the specified key is not already associated with a value (or is mapped to null) associates
it with the given value and returns null, else returns the current value.
4.remove(Object key, Object value)
Removes the entry for the specified key only if it is currently mapped to the specified value.
5.replace(K key, V value)
Replaces the entry for the specified key only if it is currently mapped to some value.
6.replace(K key, V oldValue, V newValue)
Replaces the entry for the specified key only if currently mapped to the specified value.
7.replaceAll(BiFunction<? super K,? super V,? extends V> function)
Replaces each entry's value with the result of invoking the given function on that entry until all entries have been
processed or the function throws an exception.
    Advantages of Hashtable
1.Thread-safe
2.Simple to use
    Disadvantages of Hashtable
1.Obsolete
2.Limited functionality
3.Poor performance
4.Null Support
5.Iterator Issue
    Differences between HashMap and HashTable in Java
Hashmap	                                        Hashtable
No method is synchronized.                      Every method is synchronized.
Null is allowed for both key and value.         Null is not allowed for both key and value. Otherwise, we will get a null pointer exception.

    HashMap
A HashMap is a part of Java’s Collection Framework and implements the Map interface.
It stores elements in key-value pairs, where:
-Keys are unique.
-Values can be duplicated.
-Data is stored using hashing for quick access, insertion, and deletion.
Internally uses Hashing (similar to Hashtable in Java).
    Key Features of HashMap
-Not synchronized
-Allows to store the null keys as well, but there should be only one null key object, and there can be any number of null values.
-Duplicate keys are not allowed in HashMap
if you try to insert a duplicate key, it will replace the existing value of the corresponding key.
-HashMap uses keys in the same way as an Array uses an index.
It takes two parameters namely as follows
-The type of keys maintained by this map
-The type of mapped values
    Capacity of HashMap
The capacity of a HashMap is the number of buckets it can hold for storing entries.
new capacity=old capacity×2
Default capacity: Default capacity of hashmap is 16.
Load factor: 0.75 (default): when 75% of the capacity is filled, the capacity is doubled.
    Java HashMap Constructors
1. HashMap()
It is the default constructor which creates an instance of HashMap with an initial capacity of 16 and a load factor of 0.75.
2.HashMap(int initialCapacity)
It creates a HashMap instance with a specified initial capacity and load factor of 0.75.
3.HashMap(int initialCapacity, float loadFactor)
It creates a HashMap instance with a specified initial capacity and specified load factor.
4.HashMap(Map map)
It creates an instance of HashMap with the same mappings as the specified map.
    Performing Various Operations on HashMap
1. Adding Elements in HashMap in Java
To add an element to the map, we can use the put() method.
However, the insertion order is not retained in the Hashmap.
2. Changing Elements in HashMap in Java
After adding the elements if we wish to change the element,
it can be done by again adding the element with the put() method.
3. Removing Element from Java HashMap
To remove an element from the Map, we can use the remove() method.
This method takes the key value and removes the mapping for a key from this map if it is present in the map.
4. Traversal of Java HashMap
We can use the Iterator interface to traverse over any structure of the Collection Framework.
Since Iterators work with one type of data we use Entry< ? , ? > to resolve the two separate types into a compatible format.
Then using the next() method we print the entries of HashMap.
    Synchronized HashMap
HashMap is unsynchronized meaning multiple threads can access it at the same time.
If at least one thread modifies it, you must synchronize externally.
wrap with Collections.synchronizedMap()  to prevent concurrent access issues.
    Map m = Collections.synchronizedMap(new HashMap(...));
Now the Map m is synchronized
Iterators of this class are fail-fast if any structure modification is done after the creation of the iterator,
in any way except through the iterator's remove method.
In a failure of an iterator, it will throw ConcurrentModificationException.
    Methods of HashMap
K – The type of the keys in the map.
V – The type of values mapped in the map.
1.clear(): Removes all of the mappings from this map.
2.clone(): Returns a shallow copy of this HashMap instance.
3.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)
Attempts to update or compute a mapping for the specified key and its current mapped value
4.computeIfAbsent(K key, Function<?super K,? extends V> mappingFunction)
Adds computed value if key absent/null.
5.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)
If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value.
6.containsKey(Object key): Returns true if this map contains a mapping for the specified key.
7.containsValue(Object value): Returns true if this map maps one or more keys to the specified value.
8.entrySet(): Returns a Set view of the mappings contained in this map.
9.get(Object key): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.
10.isEmpty(): Returns true if this map contains no key-value mappings.
11.keySet(): Returns a Set view of the keys contained in this map.
12.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)
If the specified key is not already associated with a value or is associated with null, associate it with the given non-null value.
13.put(K key, V value): Associates the specified value with the specified key in this map.
14.putAll(Map<? extends K,? extends V> m): Copies all of the mappings from the specified map to this map.
15.remove(Object key): Removes the mapping for the specified key from this map if present.
16.size(): Returns the number of key-value mappings in this map.
17.values(): Returns a Collection view of the values contained in this map.
     Methods inherited from class java.util.AbstractMap
1.equals(): Compares the specified object with this map for equality.
2.hashCode(): Returns the hash code value for this map.
3.toString(): Returns a string representation of this map.
    Methods inherited from interface java.util.Map
1.equals(): Compares the specified object with this map for equality.
2.forEach(BiConsumer<? super K, ? super V> action)
Performs the given action for each entry in this map until all entries have been processed or the action throws an exception.
3.getOrDefault(Object key, V defaultValue)
Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key.
4.hashCode(): Returns the hash code value for this map.
5.putIfAbsent(K key, V value)
If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value.
6.remove(Object key, Object value)
Removes the entry for the specified key only if it is currently mapped to the specified value.
7.replace(K key, V value): Replaces the entry for the specified key only if it is currently mapped to some value.
8.replace(K key, V oldValue, V newValue): Replaces the entry for the specified key only if currently mapped to the specified value.
9.replaceAll(BiFunction<? super K,? super V,? extends V> function)
Replaces each entry's value with the result of invoking the given function on that entry until all entries have
been processed or the function throws an exception.

    LinkedHashMap
LinkedHashMap in Java implements the Map interface of the Collections Framework.
It stores key-value pairs while maintaining the insertion order of the entries.
-Stores unique key-value pairs.
-Maintains insertion order.
-Allows one null key and multiple null values.
-Fast performance for basic operations.
The LinkedHashMap Class is just like HashMap
with an additional feature of maintaining an order of elements inserted into it
    Internal Working of LinkedHashMap
A LinkedHashMap is an extension of the HashMap class and it implements the Map interface.
In this class, the data is stored in the form of nodes.
The implementation of the LinkedHashMap is very similar to a doubly-linked list.
herefore, each node of the LinkedHashMap is represented as:
Previous Key Value Next
Next: Since the LinkedHashMap stores the insertion order, this contains the address to the next node of the LinkedHashMap.
Previous: This parameter contains the address to the previous node of the LinkedHashMap.
    Synchronized LinkedHashMap
The LinkedHashMap class is not synchronized.
If it is used in a multi-threaded environment where structural modifications like adding
or removing elements are made concurrently then external synchronization is needed.
This can be done by wrapping the map using Collections.synchronizedMap() method.
    Constructors of LinkedHashMap Class
LinkedHashMap class provides various constructors for different use cases.
1.LinkedHashMap(): This is used to construct a default LinkedHashMap constructor.
    LinkedHashMap<K, V> lhm = new LinkedHashMap<>();
2.LinkedHashMap(int capacity): It is used to initialize a particular LinkedHashMap with a specified capacity.
    LinkedHashMap<K, V> lhm = new LinkedHashMap<>(int capacity);
3.LinkedHashMap(Map<? extends K, extends V> map):
It is used to initialize a particular LinkedHashMap with the elements of the specified map.
    LinkedHashMap<K, V> lhm = new LinkedHashMap<K, V>(Map<? extends K, extends V> map);
4.LinkedHashMap(int capacity, float fillRatio)
It is used to initialize both the capacity and fill ratio for a LinkedHashMap.
-loadFactor: is a metric that determines when to increase the size of the LinkedHashMap automatically.
By default, this value is 0.75 which means that the size of the map is increased when the map is 75% full.
    LinkedHashMap<K, V> lhm = new LinkedHashMap<K, V>(int capacity, float fillRatio);
5. LinkedHashMap(int capacity, float fillRatio, boolean Order)
his constructor is also used to initialize both the capacity and fill ratio for a
LinkedHashMap along with whether to follow the insertion order or not.
    LinkedHashMap<K, V> lhm = new LinkedHashMap<K, V>(int capacity, float fillRatio, boolean Order);
    Methods of LinkedHashMap
1.containsValue(Object value): Returns true if this map maps one or more keys to the specified value.
2.entrySet(): Returns a Set view of the mappings contained in this map.
3.get(Object key): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.
4.keySet(): Returns a Set view of the keys contained in this map.
5.removeEldestEntry(Map.Entry<K,V> eldest): Returns true if this map should remove its eldest entry.
6.values(): Returns a Collection view of the values contained in this map.
    Performing Various Operations on LinkedHashMap
1. Adding Elements in LinkedHashMap
In order to add an element to the LinkedHashMap, we can use the put() method.
2. Updating Elements in LinkedHashMap
After adding elements if we wish to change the element, it can be done by again adding the element using the put() method.
3.Removing Element in LinkedHashMap
In order to remove an element from the LinkedHashMap, we can use the remove() method.
4. Iterating through the LinkedHashMap
There are multiple ways to iterate through the LinkedHashMap.
The most famous way is to use a for-each loop over the set view of the map
(fetched using map.entrySet() instance method).
    Advantages of LinkedHashMap
-It maintains insertion order.
-Faster iteration.
-Allows null values.
    Disadvantages of LinkedHashMap
-Higher memory usage.
-Slower insertion.
-Less efficient for large datasets.

     ConcurrentHashMap in Java
In Java, the ConcurrentHashMap is a thread-safe implementation of the Map interface.
It allows multiple threads to read and write data simultaneously
-The default concurrency level of ConcurrentHashMap is 16
    Constructors
-Concurrency-Level: It is the number of threads concurrently updating the map.
-Load-Factor: It’s a threshold, used to control resizing.
-Initial Capacity: Accommodation of a certain number of elements initially provided by the implementation.
    Constructor
-ConcurrentHashMap(): This constructor creates a new, empty map with a default initial capacity (16),
load factor (0.75) and concurrencyLevel (16).
-ConcurrentHashMap(int initialCapacity): This constructor creates a new, empty map with the specified initial capacity,
and with default load factor (0.75) and concurrencyLevel (16).
-ConcurrentHashMap(int initialCapacity, float loadFactor): This constructor creates a new,
empty map with the specified initial capacity and load factor and with the default concurrencyLevel (16)
-ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel):
This constructor creates a new, empty map with the specified initial capacity, load factor, and concurrency level.
-ConcurrentHashMap(Map m): This constructor creates a new map with the same mappings as the given map.
       Performing Various Operations on ConcurrentHashMap
1.Adding Elements: We can use put() or putAll() to insert element to a ConcurrentHashMap.
2.Removing Elements: We can use the remove() method to remove elements from the ConcurrentHashMap.
To clear the entire map, we can use the clear().
3.Accessing Elements: We can use the  get() method to access the elements of the ConcurrentHashMap.
4.Iterating Elements: We can use the Iterator interface to traverse over the elements of ConcurrentHashMap.
Note:
If a thread-safe highly-concurrent implementation is desired,
then it is recommended to use ConcurrentHashMap in place of Hashtable.

    SortedMap
SortedMap is an interface in the collection framework that is a part of java.util package and extends the Map interface
It represents a map that maintains its keys in a sorted order
The keys in a SortedMap are sorted according to their natural ordering or by a Comparator provided at the time of map creation.
The primary class that implements SortedMap is TreeMap which maintains elements in a Red-Black tree structure to ensure sorting.
-A comparator can be passed to customize the sorting order of the keys.
-SortedMap does not allow null keys or null values. If we insert a null key or value it will throw an error.
    Creating SortedMap Objects
Since SortedMap is an interface, we cannot directly crate object of this type.
we need to use a class that implements this interface such as TreeMap or ConcurrentSkipListMap for a thread-safe version.
    Performing Various Operations on SortedMap Interface
1. Adding Elements
We can use the put() method to insert element in an SortedMap.
2. Changing Elements
To change the element in a SortedMap, we can use the put() method again with the same key but a new value.
Since the map stores elements using keys, updating the value is as simple as adding the key with its new value.
3. Removing Element
We can use the remove() method to remove an element from the SortedMap.
4. Iterating Element: There are multiple ways to iterate through the Map.
The most famous way is to use an enhanced for loop and get the keys.
The value of the key is found by using the getValue() method.
Note:
-The class which implements the SortedMap interface is TreeMap.
-TreeMap uses a tree data structure for storage. Objects are stored in sorted, ascending order.
-But we can also store in descending order by passing a comparator.
    Methods
1.comparator():
Returns the comparator used to order the keys in this map, or null if this map uses the natural ordering of its keys.
2.entrySet(): Returns a Set view of the mappings contained in this map.
3.firstKey(): Returns the first (lowest) key currently in this map.
4.headMap(K toKey): Returns a view of the portion of this map whose keys are strictly less than toKey.
5.keySet(): Returns a Set view of the keys contained in this map.
6.lastKey(): Returns the last (highest) key currently in this map.
7.subMap(K fromKey, K toKey): Returns a view of the portion of this map whose keys range from fromKey, inclusive, to toKey, exclusive.
8.tailMap(K fromKey): Returns a view of the portion of this map whose keys are greater than or equal to fromKey.
9.values(): Returns a Collection view of the values contained in this map.
    Methods Inherited from Interface java.util.Map
1.clear():  This method is used to clear and remove all of the elements or mappings from a specified Map collection.
2.containsKey(Object): This method is used to check whether a particular key is being mapped into the Map or not.
3.containsValue(Object) : This method is used to check whether a particular value is being mapped by a single or more than one key in the Map.
4.entrySet(): This method is used to create a set out of the same elements contained in the map
5.equals(Object): This method is used to check for equality between two maps
6.get(Object): This method is used to retrieve or fetch the value mapped by a particular key mentioned in the parameter.
7.hashCode(): This method is used to generate a hashCode for the given map containing key and values.
8.isEmpty(): This method is used to check if a map is having any entry for key and value pairs.
9.keySet(): This method is used to return a Set view of the keys contained in this map.
10.put(Object, Object): his method is used to associate the specified value with the specified key in this map.
11.putAll(Map): This method is used to copy all of the mappings from the specified map to this map.
12.remove(Object): This method is used to remove the mapping for a key from this map if it is present in the map.
13.size(): This method is used to return the number of key/value pairs available in the map.
14.values(): This method is used to create a collection out of the values of the map.

    NavigableMap Interface
The NavigableMap interface is a member of the Java Collection Framework.
It belongs to java.util package and It is an extension of SortedMap .
Which provides convenient navigation methods for dealing with elements that are sorted based on their keys.
This interface allows us to navigate through the map's keys in a more efficient and flexible manner,
-In NavigableMap entries are automatically sorted by their keys, allowing easy navigation in both forward and reverse order.
    Implementing Classes
The NavigableMap has two implementing classes which are ConcurrentSkipListMap and TreeMap.
    Performing Various Operations on NavigableMap Interface
1. Adding Elements:
To add elements to a NavigableMap we can use any methods of the Map interface.
2. Removing Elements: We can use the remove() method to remove elements from the NavigableMap.
If we want to remove all the elements from the map we can use clear() method.
3. Accessing Elements:  We can access the elements of a NavigableMap using get() method.
4. Iterating Elements: We can use the Iterator interface to traverse a NavigableMap.
-To handle the key-value pairs, we use Map.Entry<?> and the next() method to access element.
Alternatively, we can use a for-each loop to get keys and fetch values using getValue() method.
    Methods
NavigableMap inherits methods from the Map interface, SortedMap interface.
K: The type of the keys in the map.
V: The type of values mapped in the map.
1.ceilingEntry(K key):
Returns a key-value mapping associated with the least key greater than or equal to the given key
2.ceilingKey(K key): Returns the least key greater than or equal to the given key, or null if there is no such key.
3.descendingKeySet(): Returns a reverse order NavigableSet view of the keys contained in this map.
4.descendingMap(): Returns a reverse order view of the mappings contained in this map.
5.firstEntry(): Returns a key-value mapping associated with the least key in this map, or null if the map is empty.
6.floorEntry(K key): Returns a key-value mapping associated with the greatest key less than or equal to the given key, or null if there is no such key.
7.floorKey(K key): Returns the greatest key less than or equal to the given key, or null if there is no such key.
8.headMap(K toKey): Returns a view of the portion of this map whose keys are strictly less than toKey.
9.headMap(K toKey, boolean inclusive): Returns a view of the portion of this map whose keys are less than (or equal to, if inclusive is true) toKey.
10.higherEntry(K key): Returns a key-value mapping associated with the least key strictly greater than the given key, or null if there is no such key.
11.higherKey(K key): Returns the least key strictly greater than the given key, or null if there is no such key.
12.lastEntry(): Returns a key-value mapping associated with the greatest key in this map, or null if the map is empty.
13.lowerEntry(K key): Returns a key-value mapping associated with the greatest key strictly less than the given key, or null if there is no such key.
14.lowerKey(K key): Returns the greatest key strictly less than the given key, or null if there is no such key.
15.navigableKeySet(): Returns a NavigableSet view of the keys contained in this map.
16.pollFirstEntry(): Removes and returns a key-value mapping associated with the least key in this map, or null if the map is empty.
17.pollLastEntry(): Removes and returns a key-value mapping associated with the greatest key in this map, or null if the map is empty.
18.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
Returns a view of the portion of this map whose keys range from fromKey to toKey.
19.subMap(K fromKey, K toKey): Returns a view of the portion of this map whose keys range from fromKey, inclusive, to toKey, exclusive.
20.tailMap(K fromKey): Returns a view of the portion of this map whose keys are greater than or equal to fromKey.
21.tailMap(K fromKey, boolean inclusive):
Returns a view of the portion of this map whose keys are greater than (or equal to, if inclusive is true) fromKey.
    Methods Inherited from Interface java.util.SortedMap
1.comparator(): Returns the comparator used to order the keys in this map, or null if this map uses the natural ordering of its keys.
2.entrySet(): Returns a Set view of the mappings contained in this map.
3.firstKey(): Returns the first (lowest) key currently in this map.
4.keySet(): Returns a Set view of the keys contained in this map.
5.lastKey(): Returns the last (highest) key currently in this map.
6.values(): Returns a Collection view of the values contained in this map.
    Methods Inherited from Interface java.util.Map
1.clear(): Removes all of the mappings from this map.
2.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)
Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping).
3.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)
If the specified key is not already associated with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into this map unless null.
4.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)
If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value.
5.containsKey(Object key): Returns true if this map contains a mapping for the specified key.
6.containsValue(Object value): 	Returns true if this map maps one or more keys to the specified value.
7.equals(Object o): Compares the specified object with this map for equality.
8.forEach(BiConsumer<? super K,? super V> action):
Performs the given action for each entry in this map until all entries have been processed or the action throws an exception.
9.get(Object key): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.
10.getOrDefault(Object key, V defaultValue)
Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key.
11.hashCode(): Returns the hash code value for this map.
12.isEmpty(): Returns true if this map contains no key-value mappings.
13.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)
If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value.
14.put(K key, V value): Associates the specified value with the specified key in this map.
15.putAll(Map<? extends K,? extends V> m): Copies all of the mappings from the specified map to this map.
16.putIfAbsent(K key, V value): If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value.
17.remove(Object key): Removes the mapping for a key from this map if it is present.
18.remove(Object key, Object value): Removes the entry for the specified key only if it is currently mapped to the specified value.
19.replace(K key, V value): Replaces the entry for the specified key only if it is currently mapped to some value.
20.replace(K key, V oldValue, V newValue):
Replaces the entry for the specified key only if currently mapped to the specified value.
21.replace(K key, V oldValue, V newValue)
Replaces the entry for the specified key only if currently mapped to the specified value.
22.replaceAll(BiFunction<? super K,? super V,? extends V> function)
Replaces each entry's value with the result of invoking the given function on that entry until all entries have been processed or the function throws an exception.
23.size(): Returns the number of key-value mappings in this map.

    ConcurrentMap Interface
It is designed for thread-safe concurrent access to its entries without compromising the consistency of the map.
The interface resides in the java.util.concurrent package and extends the Map interface.
HashMap operations are not synchronized
while Hashtable provides synchronization
Though Hashtable is thread-safe, it is not very efficient.
To solve this issue, the Java Collections Framework introduced ConcurrentMap
-It extends the Map interface in Java
-ConcurrentNavigableMap<K,V> is the SubInterface.
-ConcurrentMap is implemented by ConcurrentHashMap, and ConcurrentSkipListMap classes.
-ConcurrentMap is known as a synchronized Map.
    Declaration of ConcurrentMap Interface
ConcurrentMap<K, V> map = new ConcurrentHashMap<K, V>();
Note: Here, "k" is the type of the key, and "v" is the type of value.
    Implementing Classes
To use ConcurrentMap we need to import it from the Java.util.concurrent package
import java.util.concurrent.ConcurrentMap;
or
import java.util.concurrent.*;
    ConcurrentMap is implemented by two classes which are
ConcurrentHashMap and ConcurrentSkipListMap.
-ConcurrentHashMap is a high performance thread-safe map
-ConcurrentSkipListMap is a thread-safe, sorted map
    Performing Various Operations on ConcurrentMap
1. Adding Elements:
The put() method of ConcurrentSkipListMap is an in-built function in Java which associates the specified
value with the specified key in this map.
2. Removing Elements
The remove() method of ConcurrentSkipListMap is an in-built function in Java which removes the mapping for the specified key from this map.
3. Accessing Elements
We can access the elements of a ConcurrentSkipListMap using the get() method.
4. Iterating Elements
We can use the iterator to traverse a ConcurrentMap by iterating over its Entry set accessing
each key-value pair with next() method.
    Methods
1.compute(K key, BiFunction<? super K,? superV,? extends V> remappingFunction)
Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping).
2.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)
If the specified key is not already associated with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into this map unless null.
3.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)
If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value.
4.forEach(BiConsumer<? super K,? super V> action)
Performs the given action for each entry in this map until all entries have been processed or the action throws an exception.
5.getOrDefault(Object key, V defaultValue)
Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key.
6.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)
If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value.
7.putIfAbsent(K key, V value): If the specified key is not already associated with a value, associates it with the given value.
8.remove(Object key, Object value): Removes the entry for a key only if currently mapped to a given value.
9.replace(K key, V value): Replaces the entry for a key only if currently mapped to some value.
10.replace(K key, V oldValue, V newValue): Replaces the entry for a key only if currently mapped to a given value.
11. replaceAll(BiFunction<? super K,? super V,? extends V> function)
Replaces each entry’s value with the result of invoking the given function on that entry until all entries have
been processed or the function throws an exception.
    Methods Inherited from Interface java.util.Map
1.clear(): Removes all of the mappings from this map (optional operation).
2.containsKey(Object key): Returns true if this map contains a mapping for the specified key.
3.containsValue(Object value): Returns true if this map maps one or more keys to the specified value.
4.entry(K k, V v): Returns an immutable Map.Entry containing the given key and value.
5.entrySet(): Returns a Set view of the mappings contained in this map.
6.equals(Object o): Compares the specified object with this map for equality.
7.get(Object key): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.
8.hashCode(): Returns the hash code value for this map.
9.isEmpty(): Returns true if this map contains no key-value mappings.
10.keySet(): Returns a Set view of the keys contained in this map.
11.of(): Returns an immutable map containing zero mappings.
12.of(K k1, V v1): Returns an immutable map containing a single mapping.
13.ofEntries(Map.Entry<? extends K,? extends V>… entries)
Returns an immutable map containing keys and values extracted from the given entries.
14.put(K key, V value): Associates the specified value with the specified key in this map (optional operation).
15.putAll(Map<? extends K,? extends V> m)
Copies all of the mappings from the specified map to this map (optional operation).
16.remove(Object key): Removes the mapping for a key from this map if it is present
17.size(): Returns the number of key-value mappings in this map.
18.values(): Returns a Collection view of the values contained in this map.
    TreeMap
TreeMap in Java is an implemented class that extends Map
storing key-value pairs in a sorted order
    Key Features of TreeMap
-The keys in a TreeMap are always sorted.
-TreeMap does not allow null as a key; it allows null as a value
-TreeMap is not synchronized.
-Entry pairs returned by the methods in this class and their views represent snapshots of mappings at the time they were produced.
    Constructors of TreeMap
In order to create a TreeMap, we need to create an object of the TreeMap class.
The following are the constructors available in this class:
1. TreeMap():
This constructor is used to build an empty TreeMap that will be sorted by using the natural order of its keys.
    TreeMap<K, V> map = new TreeMap<>();
2. TreeMap(Comparator comp)
This constructor is used to build an empty TreeMap object in which the elements will need an external specification of the sorting order.
3. TreeMap(Map M)
This constructor is used to initialize a TreeMap with the entries from the given map M which will be sorted by using the natural order of the keys.
    Performing Various Operations on TreeMap
1. Adding Elements
We can use the put() method to insert elements to a TreeMap.
for every element, the keys are compared and sorted in ascending order.
2.Changing Elements
To change the element in a TreeMap, simply use the put() method again with the same key and the new value.
3. Removing Element
We can use the remove() method to remove element from the TreeMap.
4. Iterating Elements
There are multiple ways to iterate through the Map. The most famous way is to use a for-each loop and get the keys.
The value of the key is found by using the getValue() method.
    Methods of TreeMap
1.clear(): The method removes all mappings from this TreeMap and clears the map.
2.clone(): The method returns a shallow copy of this TreeMap.
3.containsKey(Object key): Returns true if this map contains a mapping for the specified key.
4.containsValue(Object value): Returns true if this map maps one or more keys to the specified value.
5.entrySet(): Returns a set view of the mappings contained in this map.
6.firstKey(): Returns the first (lowest) key currently in this sorted map.
7.get(Object key): Returns the value to which this map maps the specified key.
8.headMap(Object key_value): The method returns a view of the portion of the map strictly less than the parameter key_value.
9.keySet(): The method returns a Set view of the keys contained in the treemap.
10.lastKey(): Returns the last (highest) key currently in this sorted map.
11.put(Object key, Object value): The method is used to insert a mapping into a map.
12.putAll(Map map): Copies all of the mappings from the specified map to this map.
13.remove(Object key): 	Removes the mapping for this key from this TreeMap if present.
14.size(): Returns the number of key-value mappings in this map.
15.subMap((K startKey, K endKey): The method returns the portion of this map whose keys range from startKey, inclusive, to endKey, exclusive.
16.values(): Returns a collection view of the values contained in this map.

    1. Core Interfaces
The foundation of the Collections Framework is built on interfaces like Collection, List, Set, Queue, Deque and Map.
They define the behavior of different collection types and serve as a blueprint for implementations.
    1-Collection Interface
is a core member of the Java Collections Framework located in the java.util package.
The Collection interface is not directly implemented by any class.
it is implemented indirectly through its sub-interfaces like List, Queue, and Set.
    Sub Interfaces Collection Interface
-List
-Set
-Queue
-Deque
-SortedSet
-NavigableSet

    2-List Interface
List Interface provides a blueprint for the implementation of list classes.
    Implementation of List Interface
-ArrayList class
-LinkedList class
-Vector class
-Stack class
-AbstractList Interface
-AbstractSequentialList Interface

    3-Set Interface
A Set represents a collection of unique elements, meaning it does not allow duplicate values.
    Implementation of Set Interface
-HashSet class
-LinkedHashSet class
-TreeSet class
-EnumSet
-SortedSet Interface
-NavigableSet Interface
-ConcurrentSkipListSet class

    4.Queue Interface
This extends the Collection interface.
    Key Features
-FIFO Order : Elements are processed in the order they were inserted (First-In-First-Out).
- Unlike List, elements cannot be accessed directly by index.
-Multiple Variants : Includes PriorityQueue, Deque, ArrayDeque and LinkedList implementations.
-Two Sets of Methods : Throws-exception versions (add, remove, element) and safe versions (offer, poll, peek).
We cannot instantiate a Queue directly as it is an interface.
Here, we can use a class like LinkedList or PriorityQueue that implements this interface.
    Common Methods
1.add(element): Adds an element to the rear of the queue. If the queue is full, it throws an exception.
2.offer(element): Adds an element to the rear of the queue. If the queue is full, it returns false.
3.remove(): Removes and returns the element at the front of the queue. If the queue is empty, it throws an exception.
4.poll(): Removes and returns the element at the front of the queue. If the queue is empty, it returns null.
element(): Returns the element at the front of the queue without removing it. If the queue is empty, it throws an exception.
peek(): Returns the element at the front of the queue without removing it. If the queue is empty, it returns null.
    Classes that implement the Queue Interface
-PriorityQueue
PriorityQueue class lets us process elements based on their priority instead of the usual FIFO order of a normal queue.
It’s useful when elements must be handled in priority order
- LinkedList
LinkedList is a linear data structure where elements are stored as separate objects, each containing data and a link to the next element.
-PriorityBlockingQueue
PriorityBlockingQueue is a thread-safe,
unbounded blocking queue that orders elements like PriorityQueue and supports blocking retrieval.
    Methods of Queue Interface
1.add(E e): Inserts element; throws exception if full.
2.offer(E e): Inserts element; returns false if full.
3.remove(): Removes head; throws exception if empty.
4.poll(): Removes head; returns null if empty.
5.element(): Retrieves head; throws exception if empty.
6.peek(): Retrieves head; returns null if empty.
7.addAll(Collection<? extends E> c): Adds all elements from another collection.
8.clear(): Removes all elements.
9.contains(Object o): Checks if element exists.
10.containsAll(Collection<?> c): Checks if all elements exist.
11.equals(Object o): Compares with another collection.
12.hashCode(): Returns hash code.
13.isEmpty(): Checks if collection is empty.
14.iterator(): Returns iterator for elements.
15.remove(Object o): Removes a specific element.
16.removeAll(Collection<?> c): Removes all matching elements.
17.retainAll(Collection<?> c): Keeps only specified elements.
18.size(): Returns number of elements.
19.toArray(): Returns elements as an array.
20.toArray(T[] a): Returns elements as a typed array.
21.forEach(Consumer<? super E> action): Performs action for each element.
22.void forEach(Consumer<? super E> action): Performs action for each element.
23.Spliterator<E> spliterator(): Returns a spliterator.
24.Stream<E> stream(): Returns a sequential stream.
25.Stream<E> parallelStream(): Returns a parallel stream.

    5.Deque Interface
A Deque (double-ended queue) allows adding or removing elements from both ends
and can work as either a FIFO queue or a LIFO stack.
-Supports FIFO and LIFO : Can function as a queue (FIFO) or a stack (LIFO).
-No Capacity Restriction
-More Versatile than Queue
-Efficient Insert/Remove at Both End
-The class which implements the Deque interface is ArrayDeque.
Deque Interface extends the Queue Interface
Since Deque is an interface, objects cannot be created of the type Deque
    class which implements the Deque interface
-ArrayDeque
    Deque Operations using ArrayDeque
1.Adding Elements
In order to add an element in a Deque, we can use the add() method.
The difference between a Queue and a Deque is that in Deque, the addition is possible from any direction.
Therefore, there are other two methods available named addFirst() and addLast() which are used to add the elements at either end.
2. Removing Elements
In order to remove an element from a Deque, there are various methods available.
-Since we can also remove from both ends, the Deque interface provides us with removeFirst(), removeLast() methods.
-This interface also provides us with the poll(), pop(), pollFirst(), pollLast() methods where pop() is used to remove and return the head of the Deque.
-However, poll() is used because this offers the same functionality as pop() and doesn't return an exception when the Deque is empty.
3. Iterating through the Deque
Since a Deque can be iterated from both directions,
the iterator method of the Deque interface provides us two ways to iterate.
One from the first and the other from the back.
    ArrayDeque
-ArrayDeque in the Java Collection Framework is a resizable array that allows adding or removing elements from both ends.
-It has no capacity limit and grows as needed. It is not thread-safe.
-ArrayDeque is usually faster than Stack for stack operations and faster than LinkedList for queue operations.
    Methods of Deque Interface
- addFirst(E e): Inserts element at the front; throws exception if full.
-addLast(E e): Inserts element at the end; throws exception if full.
-offerFirst(E e): Inserts at front; returns false if full.
-offerLast(E e): Inserts at end; returns false if full.
-removeFirst(): Removes and returns first element; throws exception if empty.
-removeLast(): Removes and returns last element; throws exception if empty.
-pollFirst(): Removes and returns first element; returns null if empty.
-pollLast(): Removes and returns last element; returns null if empty.
-getFirst(): Retrieves first element without removing; throws exception if empty.
-getLast(): Retrieves last element without removing; throws exception if empty.
-peekFirst(): Retrieves first element without removing; returns null if empty.
-peekLast(): Retrieves last element without removing; returns null if empty.
-removeFirstOccurrence(Object o): Removes first occurrence of the element.
-removeLastOccurrence(Object o): Removes last occurrence of the element.
-Iterator<E> descendingIterator(): Returns iterator from tail to head.
-add(E e): Inserts at tail; throws exception if full.
-offer(E e): Inserts at tail; returns false if full.
-remove(): Removes head; throws exception if empty.
-poll(): Removes head; returns null if empty.
-element(): Retrieves head; throws exception if empty.
-peek(): Retrieves head; returns null if empty.
     Queue / Deque Implementations
1)AbstractQueue
The AbstractQueue class in Java is a part of the Java Collection Framework.
Implements the Collection interface and the AbstractCollection class.
-It provides skeletal implementations of some Queue operations.
-Methods add, remove, and element are based on offer, poll, and peek, respectively,
    Key Features of AbstractQueue
-Abstract Class
It is an abstract class, meaning it cannot be instantiated directly.
It serves as a base class for concrete queue implementations.
-Provides default implementations for common methods of the Queue interface.
- it does not provide methods to block threads, instead it focuses on basic queue behavior.
    Constructors in Java AbstractQueue
 The default constructor, but being abstract, it doesn't allow to create an AbstractQueue object.
    Subclasses of Abstract Queue
-ArrayBlockingQueue
-ConcurrentLinkedQueue
-DelayQueue
-LinkedBlockingDeque
-LinkedBlockingQueue
-LinkedTransferQueue
-PriorityBlockingQueue
-PriorityQueue
-SynchronousQueue.
    Basic Operations
1. Adding Elements:
To add elements into the AbstractQueue, it provides two methods.
The add(E e) method inserts the specified element into this queue if it is
possible to do so immediately without violating capacity restrictions.
2.Remove the Elements
To remove the elements from AbstractQueue, it provides remove() and clear() methods.
-The remove() method returns and removes the head of this queue.
-The clear() method removes all the elements from this queue. The queue will be empty after this call returns.
3. Accessing the Elements
The element() method of AbstractQueue retrieves but does not remove, the head of this queue.
    Methods of AbstractQueue
1.add(E e): Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions.
2.addAll(Collection<? extends E> c): Adds all the elements in the specified collection to this queue.
3.clear(): Removes all the elements from this queue.
4.element(): Retrieves, but does not remove, the head of this queue.
5.remove(): Retrieves and removes the head of this queue.
    Methods declared in class java.util.AbstractCollection
1.contains(Object o): Returns true if this collection contains the specified element.
2.containsAll(Collection<?> c): Returns true if this collection contains all of the elements in the specified collection.
3.isEmpty(): Returns true if this collection contains no elements.
4.iterator(): Returns an iterator over the elements contained in this collection.
5.remove(Object o): Removes a single instance of the specified element from this collection, if it is present.
6.removeAll(Collection<?> c): Removes all of this collection's elements that are also contained in the specified collection.
7.retainAll(Collection<?> c): Retains only the elements in this collection that are contained in the specified collection.
8.toArray(): Returns an array containing all of the elements in this collection.
9.toArray(T[] a): Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array.
10.toString(): Returns a string representation of this collection.
    Methods declared in interface java.util.Collection
1.contains(Object o): Returns true if this collection contains the specified element.
2.containsAll(Collection<?> c): Returns true if this collection contains all the elements in the specified collection.
3.equals(Object o): Compares the specified object with this collection for equality.
4.hashCode(): Returns the hash code value for this collection.
5.isEmpty(): Returns true if this collection contains no elements.
6.iterator(): Returns an iterator over the elements in this collection.
7.parallelStream(): Returns a possibly parallel Stream with this collection as its source.
8.remove(Object o): Removes a single instance of the specified element from this collection, if it is present
9.removeAll(Collection<?> c): Removes all of this collection's elements that are also contained in the specified collection (optional operation).
10.removeIf(Predicate<? super E> filter): Removes all the elements of this collection that satisfy the given predicate.
11.retainAll(Collection<?> c): Retains only the elements in this collection that are contained in the specified collection
12.size(): Returns the number of elements in this collection.
13.spliterator(): Creates a Spliterator over the elements in this collection.
14.stream(): Returns a sequential Stream with this collection as its source.
15.toArray(): Returns an array containing all the elements in this collection.
16.toArray(IntFunction<T[]> generator): Returns an array containing all the elements in this collection, using the provided generator function to allocate the returned array.
17.toArray(T[] a): Returns an array containing all the elements in this collection; the runtime type of the returned array is that of the specified array.
    Methods declared in interface java.lang.Iterable
1.forEach(Consumer<? super T> action): Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception.
    Methods declared in interface java.util.Queue
1.offer(E e): Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions.
2.peek(): Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty.
3.poll(): Retrieves and removes the head of this queue, or returns null if this queue is empty.
Overall, the abstract queue in Java is a versatile and powerful tool for managing collections of data in a first-in-first-out manner.
2)Priority Queue
A PriorityQueue in Java is a queue where elements are ordered based on their priority, rather than the order of insertion.
    Key feature
-The PriorityQueue is based on the Priority Heap.
-The size of the Priority Queue is dynamic, which means it will increase or decrease as per the requirement.
-PriorityQueue does not allow null values.
-We cannot create a PriorityQueue of Objects that are non-comparable.
-PriorityQueue is not thread-safe
    Constructors
1. PriorityQueue():
This method creates a PriorityQueue with the default initial capacity (11) that orders its elements according to their natural ordering.
2. PriorityQueue(Collection<E> c)
 This creates a PriorityQueue containing the elements in the specified collection.
3.PriorityQueue(int initialCapacity)
This creates a PriorityQueue with the specified initial capacity that orders its elements according to their natural ordering.
4.PriorityQueue(int initialCapacity, Comparator<E> comparator)
This creates a PriorityQueue with the specified initial capacity that orders its elements according to the specified comparator.
5.PriorityQueue(PriorityQueue<E> c): This creates a PriorityQueue containing the elements in the specified priority queue.
6.PriorityQueue(SortedSet<E> c)
This creates a PriorityQueue containing the elements in the specified sorted set.
7.PriorityQueue(Comparator<E> comparator)
This creates a PriorityQueue with the default initial capacity and whose elements are ordered according to the specified comparator.
    Different Operations on PriorityQueue
1. Adding Elements
To add an element in a priority queue, we can use the add() method.
2. Removing Elements
To remove an element from a priority queue, we can use the remove() method.
3. Accessing the Elements
Queue follows the First In First Out principle, we can access only the head of the queue.
To access elements from a priority queue, we can use the peek() method.
4. Iterating the PriorityQueue
There are multiple ways to iterate through the PriorityQueue.
The most famous way is converting the queue to the array and traversing using an iterator.
Iterator does not traverse in priority order.
    Methods in PriorityQueue Class
1.add(E e): Inserts the specified element into this priority queue.
2.clear(): Removes all of the elements from this priority queue.
3.comparator(): Returns the comparator used to order the elements in this queue or null if this queue is sorted according to the natural ordering of its elements.
4.contains?(Object o): Returns true if this queue contains the specified element.
5.forEach?(Consumer<? super E> action): Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception.
6.iterator(): Returns an iterator over the elements in this queue.
7.offer?(E e): Inserts the specified element into this priority queue.
8.remove?(Object o): Removes a single instance of the specified element from this queue, if it is present.
9.removeAll?(Collection<?> c): Removes all of this collection's elements that are also contained in the specified collection (optional operation).
10.removeIf?(Predicate<? super E> filter): Removes all of the elements of this collection that satisfy the given predicate.
11.retainAll?(Collection<?> c): Retains only the elements in this collection that are contained in the specified collection
12.spliterator(): Creates a late-binding and fail-fast Spliterator over the elements in this queue.
13.toArray(): Returns an array containing all of the elements in this queue.
14.toArray?(T[] a): Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array.
    Methods Declared in Interface java.util.Queue
1.peek(): Retrieves, but does not remove, the head of this queue or returns null if this queue is empty.
2.poll(): Retrieves and removes the head of this queue or returns null if this queue is empty.
    Methods Declared in Class java.util.AbstractQueue
1.addAll(Collection<? extends E> c): Adds all of the elements in the specified collection to this queue.
2.element(): Retrieves, but does not remove, the head of this queue.
3.remove(): Retrieves and removes the head of this queue.
    Methods Declared in Class java.util.AbstractCollection
1.containsAll(Collection<?> c): Returns true if this collection contains all of the elements in the specified collection.
2.isEmpty(): Returns true if this collection contains no elements.
3.toString(): Returns a string representation of this collection.
    Methods Declared in Interface java.util.Collection
1.containsAll(Collection<?> c): Returns true if this collection contains all of the elements in the specified collection.
2.equals(Object o): Compares the specified object with this collection for equality.
3.hashCode(): Returns the hash code value for this collection.
4.isEmpty(): Returns true if this collection contains no elements.
5.parallelStream(): Returns a possibly parallel Stream with this collection as its source.
6.size(): Returns the number of elements in this collection.
7.stream(): Returns a sequential Stream with this collection as its source.
8.toArray(IntFunction<T[]> generator): Returns an array containing all of the elements in this collection, using the provided generator function to allocate the returned array.
    ConcurrentLinkedQueue
In Java, the ConcurrentLinkedQueue is the part of the java.util.concurrent package
and implements a FIFO(First-In-First-Out) queue.
It is a thread-safe, non-blocking, and scalable queue designed for use in highly concurrent environments.
The queue maintains the order of elements as they are added.
    Constructors
1)ConcurrentLinkedQueue(): It  is used to construct an empty queue.
2)ConcurrentLinkedQueue(Collection<E> c): It  is used to construct a queue with the elements of the Collection passed as the parameter.
    Performing Various Operations on ConcurrentLinkedQueue
1. Adding Elements
We use add() and addAll() method to insert elements in a ConcurrentLinkedQueue.
2. Removing Elements
We can use remove() to remove elements from the ConcurrentLinkedQueue.
3. Iterating Elements
We can use the iterator() method of ConcurrentLinkedQueue which
return an iterator that allows traversing through the elements of the queue in the FIFO order.
4. Accessing Elements
We can use peek() and element() to access the elements of ConcurrentLinkedQueue.
    Methods of ConcurrentLinkedQueue
1.add(E e): Inserts the specified element at the tail of this queue.
2.addAll(Collection<? extends E> c): Appends all of the elements in the specified collection to the end of this queue.
3.contains(Object o): 	Returns true if this queue contains the specified element.
4.forEach(Consumer<? super E> action): Performs the given action for each element of the Iterable until all elements have been processed.
5.isEmpty(): Returns true if this queue contains no elements.
6.iterator(): Returns an iterator over the elements in this queue in the proper sequence.
7.offer(E e): Inserts the specified element at the tail of this queue.
8.remove(Object o): Removes a single instance of the specified element from this queue, if it is present.
9.removeAll(Collection<?> c): Removes all of this collection's elements that are also contained in the specified collection.
10.removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that satisfy the given predicate.
11.retainAll(Collection<?> c): Retains only the elements in this collection that are contained in the specified collection.
12.size(): Returns the number of elements in this queue.
13.spliterator(): 	Returns a Spliterator over the elements in this queue.
14.toArray(): Returns an array containing all of the elements in this queue, in the proper sequence.
15.toArray(T[] a):
Returns an array containing all of the elements in this queue, in proper sequence;
the runtime type of the returned array is that of the specified array.
    Methods Declared in Class java.util.AbstractQueue
1.clear(): Removes all the elements from this queue.
2.element(): Retrieves, but does not remove, the head of this queue.
3.remove(): Retrieves and removes the head of this queue.
    Methods Declared in Class java.util.AbstractCollection
1.containsAll(Collection<?> c): Returns true if this collection contains all of the elements in the specified collection.
2.toString(): Returns a string representation of this collection.
    Methods Declared in Interface java.util.Collection
1.clear(): Removes all of the elements from this collection.
2.containsAll(Collection<?> c): Returns true if this collection contains all of the elements in the specified collection.
3.equals(Object o): Compares the specified object with this collection for equality.
4.hashCode(): Returns the hash code value for this collection.
5.parallelStream(): Returns a possibly parallel Stream with this collection as its source.
6.stream(): Returns a sequential Stream with this collection as its source.
7.toArray(IntFunction<T[]> generator):
Returns an array containing all of the elements in this collection, using the provided generator function to allocate the returned array.
    Methods Declared in Interface java.util.Queue
1.element(): Retrieves, but does not remove, the head of this queue.
2.peek(): Retrieves, but does not remove, the head of this queue.
3.poll(): Retrieves and removes the head of this queue.
4.remove(): Retrieves and removes the head of this queue.

    6.Map Interface
Maps store data as key-value pairs where keys are unique.
    Classes that implement Map implementations
-HashMap
-LinkedHashMap
-TreeMap
-WeakHashMap
-IdentityHashMap
-HashTable
    WeakHashMap
WeakHashMap is an implementation of the Map interface.
WeakHashMap is almost the same as HashMap except in the
case of WeakHashMap if the object is specified as the key
doesn’t contain any references.
-WeakHashMap is the Hash table-based implementation of the Map interface, with weak keys.
-An entry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use.
- More precisely, the presence of a mapping for a given key will not prevent the key from being discarded by the garbage collector.
    A few important features of a WeakHashMap Class are
-Both null values and null keys are supported in WeakHashMap.
-It is not synchronized.
    Constructors in WeakHashMap
1.WeakHashMap()
This constructor is used to create an empty WeakHashMap with the default initial capacity-(16) and load factor (0.75).
2.WeakHashMap(int initialCapacity)
This constructor is used to create an empty WeakHashMap with the given initial capacity and the default load factor (0.75).
3. WeakHashMap(int initialCapacity, float loadFactor)
This constructor is used to create an empty WeakHashMap with the given initial capacity and the given load factor.
4.WeakHashMap(Map m)
This constructor is used to create a new WeakHashMap with the same mappings as the specified map.
    Methods in WeakHashMap
1.clear(): Removes all of the mappings from this map.
2.containsValue(Object value): Returns true if this map maps one or more keys to the specified value.
3.containsKey(Object key): Returns true if this map contains a mapping for the specified key.
4.entrySet(): Returns a Set view of the mappings contained in this map.
5.get(Object key): Returns the value to which the specified key is mapped.
6.isEmpty(): Returns true if this map contains no key-value mappings.
7.keySet(): Returns a Set view of the keys contained in this map.
8.put(K key, V value): Associates the specified value with the specified key in this map.
9.putAll(Map m):Copies all of the mappings from the specified map to this map.
10.remove(Object key): Removes the mapping for a key from this weak hash map if it is present.
11.size(): Returns the number of key-value mappings in this map.
12.values(): Returns a Collection view of the values contained in this map.
    IdentityHashMap
The IdentityHashMap implements Map interface using Hashtable.
This class is used when the user requires the objects to be compared via reference.
This means that two keys with the same content but different object references will be treated as distinct keys in an IdentityHashMap.
    Features of IdentityHashMap
-It follows reference equality, instead of using the equals() method it uses the == operator.
    Constructors of IdentityHashMap
1. IdentityHashMap(): Constructs a new, empty identity hash map with a default expected maximum size.
2. IdentityHashMap(int expectedMaxSize): Constructs a new, empty map with the specified expected maximum size.
3. IdentityHashMap(Map m): Constructs a new identity hash map containing the key-value mappings in the specified map.
    Basic Operations on IdentityHashMap
1. Adding Elements
To insert or add mapping into an IdentityHashMap, we have put() and putAll() methods.
2. Removing Elements: To remove mappings, we use remove().
3. Accessing the Elements
We can access the elements of an IdentityHashMap using the get() method.
4. Traversing
 Since Iterators work with one type of data we use Entry< ? , ? > to resolve the two separate types into a compatible format.
 Then using the next() method we print the elements of the IdentityHashMap.
    Methods of IdentityHashMap
1.clear(): Removes all of the mappings from this map.
2.clone():	Returns a shallow copy of this identity hash map: the keys and values themselves are not cloned.
3.containsKey?(Object key): Tests whether the specified object reference is a key in this identity hash map.
4.containsValue?(Object value): Tests whether the specified object reference is a value in this identity hash map.
5.entrySet(): Returns a Set view of the mappings contained in this map.
6.equals?(Object o): Compares the specified object with this map for equality.
7.get?(Object key): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.
8.hashCode():	Returns the hash code value for this map.
9.isEmpty(): Returns true if this identity hash map contains no key-value mappings.
10.keySet()	Returns an identity-based set view of the keys contained in this map.
11.put?(K key, V value)	Associates the specified value with the specified key in this identity hash map.
12.putAll?(Map<? extends K,?? extends V> m)	Copies all of the mappings from the specified map to this map.
13.remove?(Object key)	Removes the mapping for this key from this map if present.
14.size()	Returns the number of key-value mappings in this identity hash map.
15.values()	Returns a Collection view of the values contained in this map.
    Methods declared in class java.util.AbstractMap
1. toString()	Returns a string representation of this map.
    Methods declared in interface java.util.Map
1.compute?(K key, BiFunction<? super K,?? super V,?? extends V> remappingFunction)
Attempts to compute a mapping for the specified key and its current mapped value
2.computeIfAbsent?(K key, Function<? super K,?? extends V> mappingFunction)
If the specified key is not already associated with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into this map unless null.
3.computeIfPresent?(K key, BiFunction<? super K,?? super V,?? extends V> remappingFunction)
If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value.
4.forEach?(BiConsumer<? super K,?? super V> action)
Performs the given action for each entry in this map until all entries have been processed or the action throws an exception.
5.getOrDefault?(Object key, V defaultValue)
Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key.
6.merge?(K key, V value, BiFunction<? super V,?? super V,?? extends V> remappingFunction)
If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value.
7.putIfAbsent?(K key, V value)
If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value.
8.remove?(Object key, Object value)
Removes the entry for the specified key only if it is currently mapped to the specified value.
9.replace?(K key, V value)
Replaces the entry for the specified key only if it is currently mapped to some value.
10.replace?(K key, V oldValue, V newValue)
Replaces the entry for the specified key only if currently mapped to the specified value.
11.replaceAll?(BiFunction<? super K,?? super V,?? extends V> function)
Replaces each entry's value with the result of invoking the given function on that entry until all entries have been processed or the function throws an exception.
    IdentityHashMap vs HashMap
-IdentityHashMap uses the equality operator "==" for comparing keys and values while HashMap uses the equals method for comparing keys and values inside Map.

    Utility and Supporting Classes
Java provides helper classes and interfaces to enhance collection usage.
They include Collections, Iterator, Comparator and other tools for iteration and sorting.
