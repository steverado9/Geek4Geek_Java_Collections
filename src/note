    Java Collection Tutorial
Java Collection Framework holds all the collection classes and interfaces.
The Collection interface (java.util.Collection) and Map interface (java.util.Map).
are the two main “root” interfaces of Java collection classes.
    What is a Framework?
A framework is a set of classes and interfaces which provide a ready-made architecture.
-Collection: A group of individual objects that represent a single entity is known as a collection.
-Collection Framework: To represent a group of objects as a single entity in the Java programming
language we need classes and interfaces defined by the Collection Framework.
-Collection Interface: It is the blueprint of the collection class.
-Collections Class: It is present in java.util package and is a member of Collection Framework.
    Advantages of the collections framework
1) Reduces the programming effort as the programmer does not have to worry about designing the Collection class.
On the same hand java being object-oriented language advances in achieving "abstraction".
Abstraction in Java is the process of hiding internal implementation details and showing only essential functionality to the user.
It focuses on what an object does rather than how it does it.
2)Increases program speed and quality as the programmer now is not worried about thinking best implementation for a specific data structure.
3)The API that implements these interfaces are now having common sets of methods be it of any interfaces such as Collection, Set, List, and Map.

Note: All these collections can be imported using:
import java.util.*;

However, single classes can also be imported by replacing * with the class name
import java.util.ArrayList;
import java.util.LinkedList;

The utility package, "java.util" contains all the classes and interfaces that are required by the collection framework.
The collection framework contains an interface named an "iterable interface" which provides the iterator to iterate through all the collections.

    Iterable interface
is the root interface for the entire collection framework.
The main functionality of this interface is to provide an iterator for the collections.

    The following 6 interfaces are described below
    Collection Interface
contains all the basic methods which every collection has
like adding the data into the collection, removing the data, clearing the data, etc
All these methods are implemented in this interface because these methods are implemented by all the classes irrespective of their style of implementation.
    List Interface
It is a child interface of the collection interface.
It deals with the arrays and lists types of operations like ArrayList, LinkedList, Vector, and Stack.
    1)ArrayList
provides us with dynamic arrays in Java
The size of an ArrayList is increased automatically if the collection grows or shrinks.
    ArrayList methods
1) add() :  is used to add elements to the list.
There are two versions of the ArrayList add() method i.e.
one without specifying an index
and another with a specified index.
2)There are 3 ways to remove an element from ArrayList
-Using remove() method by indexes(default)
-Using remove() method by values
-Using remove() method over iterators
Note:
It is not recommended to use ArrayList.remove() when iterating over elements.
when using iterators,
-next is used to get the current element
-while hasNext is used to check if there is a current element
3)set() Method:  is used to replace an element at a specified position with a new value.
This is very useful when we need to update an existing element in an ArrayList while maintaining the list's structure.
    Syntax of ArrayList set() Method
set(int index, E element)
-index: Index of the element to replace.
-element: Element to be stored at the specified position.
Returns Value: It returns the element that was previously at the specified position.
4) How to Remove Duplicates from ArrayList in Java
-Using Iterator
step1: Get the ArrayList with duplicate values.
step2: Create another ArrayList.
step3: Traverse through the first arraylist and store the first appearance of each element into the second arraylist using contains() method.
step4: The second ArrayList contains the elements with duplicates removed.
-using LinkedHashSet
A better way  is to remove duplicates from an ArrayList is to convert it into a Set that does not allow duplicates.
Hence LinkedHashSet is the best option available as this do not allows duplicates as well it preserves the insertion order.
-Using Java 8 Stream.distinct()
You can use the distinct() method from the Stream API
The distinct() method return a new Stream without duplicates elements based on the result returned by equals() method,
which can be used for further processing .
 The actual processing of Stream pipeline starts only after calling terminal methods like forEach() or collect().
5)How to reverse an ArrayList
-a). By writing our own function()
    logic 1
reverseArrayList() method in RevArrayList class contains logic for reversing an arraylist with integer objects.
This method takes an arraylist as a parameter, traverses in reverse order and adds all the elements to the newly created arraylist.
Finally the reversed arraylist is returned.
    logic 2
- Run the loop for n/2 times where 'n' is the number of elements in the arraylist.
- In the first pass, Swap the first and nth element
-In the second pass, Swap the second and (n-1)th element and so on till you reach the mid of the arraylist.
-Return the arraylist after the loop termination.
-b). By using Collections class:
Collections is a class in java.util package which contains various static methods for searching, sorting, reversing, finding max, min....etc
We can make use of the In-built Collections.reverse() method for reversing an arraylist.
It takes a list as an input parameter and returns the reversed list.
-c)Reversing an arraylist of user defined objects
The arraylist is reversed using In-built reverse() method of Collections class.
-d)Using ListIterator

6)Convertng ArrayList to String Array
ArrayList class is derived from the List interface.
Here we are given an ArrayList of strings and the task is to convert the ArrayList to a string array.
Methods:
    Using get() method of ArrayList class
-Get the ArrayList of Strings.
-Find the size of ArrayList using size() method, and Create a String Array of this size.
-Fetch each element of the ArrayList one by one using get() method.
-Assigned each element into String Array using assignment(=) operator.
-Printing string array.
    Using toArray() method of ArrayList class
Here we will be creating an object array to store elements received from ArrayList by creating an array of strings.
-Get the ArrayList of String.
-Convert ArrayList to Object array using toArray() method.
-Iterate and convert each element to the desired type using typecasting.
-Here it is converted to String type and added to the string array.
-Print the string array
    Using copyOf() method of Arrays class
-Get the ArrayList of String
-Convert ArrayList to Object array using toArray() method.
-Convert it to String Array using Arrays.copyOf() method.
-Print String Array.

7)Getting a sub-list from an ArrayList
The subList() method of the ArrayList class in Java is used to retrieve a portion of an ArrayList between specified indices.
When we perform any modifications to the sub list, that will reflect in the original list and vice versa.
    Syntax of ArrayList subList() Method
public List<E> subList(int fromIndex, int toIndex);
    Parameters:
fromIndex: Starting index (inclusive) of the sublist.
toIndex: Ending index (exclusive) of the sublist.
Returns Value: It returns a view of the portion of this list between the specified indices.
    Exception: This method throws the following Exceptions.
-IndexOutOfBoundsException: If an endpoint index value is out of range (fromIndex > size).
-IllegalArgumentException: If an endpoint indices are out of order (fromIndex > toIndex).

    2)LinkedList
Linked List is a part of the Collection framework present in java.util package.
This class is an implementation of the LinkedList data structure,
which is a linear data structure where the elements are
linked using pointers and addresses, and each element is known as a node.
This class is an implementation of a doubly-linked list data structure.
Note: The nodes cannot be accessed directly instead we have to start from the head and follow the
link until we find the node that we want.
    Internal Working of LinkedList
The size of the list automatically increases when we dynamically add and remove items.
Internally, the LinkedList is implemented using the doubly linked list data structure.
-Doubly linked list:
Each node in a Doubly Linked List contains the data it holds,
a pointer to the next node in the list, and a pointer to the previous node in the list.
We can traverse the list in both directions (forward and backward), which is a key feature of a Doubly Linked List.
    Constructors in the LinkedList
In order to create a LinkedList, we need to create an object of the LinkedList class.
The LinkedList class consists of various constructors that allow the possible creation of the list.
1)LinkedList(): This constructor is used to create an empty linked list.
2) LinkedList(Collection C): This constructor is used to create an ordered list that contains all the elements of a specified collection,
as returned by the collection's iterator.
    Methods for Java LinkedList
1)add(index, element): This method inserts the specified element at the specified position in the list.
2)add(element): This method Appends the specified element to the end of the list.
3)addAll(index, Collection<E>): This method Inserts all of the elements in the specified collection into this list,
starting at the specified position.
4)addAll(Collection<E>): This method Appends all of the elements in the specified collection to the end of this list,
in the order that they are returned by the specified collection's iterator.
5)addFirst(Element): This method Inserts the specified element at the beginning of this list.
6)addLast(Element): This method Appends the specified element to the end of this list.
7)clear(): This method removes all of the elements from this list.\
8)clone(): This method returns a shallow copy of this LinkedList.
9)contains(Object o): This method returns true if this list contains the specified element.
10)descendingIterator(): This method returns an iterator over the elements in this deque in reverse sequential order.
11)element(): This method retrieves but does not remove, the head (first element) of this list.
12)get(int index): This method returns the element at the specified position in this list.
13)getFirst(): This method returns the first element in this list.
14)getLast(): This method returns the last element in this list.
15)indexOf(Object o): This method returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element.
16)lastIndexOf(Object o): This method returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element.
17)listIterator(int index): This method returns a list-iterator of the elements in this list (in proper sequence), starting at the specified position in the list.
18)offer(E e): This method Adds the specified element as the tail (last element) of this list.
19)offerFirst(E e): This method Inserts the specified element at the front of this list.
20)offerLast(E e): This method Inserts the specified element at the end of this list.
21)peek(): This method retrieves but does not remove, the head (first element) of this list.
22)peekFirst(): This method retrieves, but does not remove, the first element of this list, or returns null if this list is empty.
23)peekLast(): This method retrieves, but does not remove, the last element of this list, or returns null if this list is empty.
24)poll(): This method retrieves and removes the head (first element) of this list.
25)pollFirst(): This method retrieves and removes the first element of this list, or returns null if this list is empty.
26)pollLast(): This method retrieves and removes the last element of this list, or returns null if this list is empty.
27)pop(): This method Pops an element from the stack represented by this list.
28)push(E e): This method pushes an element onto the stack represented by this list.
29)remove(): This method retrieves and removes the head (first element) of this list.
30)remove(int index): This method removes the element at the specified position in this list.
31)remove(Object o): This method removes the first occurrence of the specified element from this list if it is present.
32)removeFirst(): This method removes and returns the first element from this list.
33)removeFirstOccurrence(Object o): This method removes the first occurrence of the specified element in this list
(when traversing the list from head to tail).
34)removeLast(): This method removes and returns the last element from this list.
35)removeLastOccurrence(Object o): This method removes the last occurrence of the specified element in this list
(when traversing the list from head to tail).
36)set(int index, E element): This method replaces the element at the specified position in this list with the specified element.
37)size(): This method returns the number of elements in this list.
38)spliterator(): This method creates a late-binding and fail-fast Spliterator over the elements in this list.
39)toArray(): This method returns an array containing all of the elements in this list in proper sequence (from first to last element).
40)toArray(T[] a): This method returns an array containing all of the elements in this list in proper sequence
(from first to last element); the runtime type of the returned array is that of the specified array.
41)toString(): This method returns a string containing all of the elements in this list in proper sequence (from first to the last element),
each element is separated by commas and the String is enclosed in square brackets.
    The classes that implement the list interface.
-AbstractList: This class is used to implement an unmodifiable list,
for which one needs to only extend this AbstractList Class and implement only the get() and the size() methods.
-CopyOnWriteArrayList: This class implements the list interface.
It is an enhanced version of ArrayList in which all the modifications(add, set, remove, etc.) are implemented by making a fresh copy of the list.
    Accessing elements of a linked list
In Java, the get() method of LinkedList is used to fetch or retrieve an element at a specific index from a LinkedList.
    Check if the LinkedList contains the Element
In Java, the contains() method of LinkedList is used to check whether an element is present in a LinkedList or not.
It takes the element as a parameter and returns True if the element is present in the list.
    Remove All Elements from a LinkedList
In Java, the clear() is used to remove all the elements from a LinkedList.
This method only clears all the element from the list and not deletes the list.
After calling this method, the list will be empty.
    Iterate over LinkedList using Iterator
In Java, the listIterator() method of the LinkedList class returns
a ListIterator that allows us to iterate over the elements of the list.
Now there are two versions of listIterator() method i.e. without index and with an index.
1. listIterator() Method with No Parameters
It creates an ListIterator that starts form the beginning of the list.
2. listIterator() Method with an Index
The listIterator(int index) method creates a ListIterator that starts iterating from the specified index in the list.

    3)Vector
Vector is a resizable array in Java, found in the java.util package.
It is part of the Collection Framework and works like an ArrayList,
but it is synchronized,
meaning it is safe to use in multi-threaded programs.
However, this makes it a bit slower than ArrayList.
   Key Features of Vector
-It expands as elements are added.
-The Vector class is synchronized in nature means it is thread-safe by default.
-Like an ArrayList, it maintains insertion order.
-It allows duplicates and nulls.
-It implements List, RandomAccess, Cloneable and Serializable.
    Vector Capacity in Java
When a Vector is created using the default constructor, it is initialized with a default capacity of 10.
This means it can hold up to 10 elements before needing to grow in size.
If the number of elements exceeds the current capacity, the Vector automatically increases its capacity.
    Formula to calculate new capacity
newCapacity = oldCapacity * 2
    Constructors of Vector
1. Vector(): Creates a default vector of the initial capacity is 10.
    Vector<E> v = new Vector<E>();
2. Vector(int size): Creates a vector whose initial capacity is specified by size.
    Vector<E> v = new Vector<E>(int size);
3. Vector(int size, int incr):  Creates a vector whose initial capacity is specified by size and increment is specified by incr.
It specifies the number of elements to allocate each time a vector is resized upward.
4. Vector(Collection c): Creates a vector that contains the elements of collection c.
Note:
-If the vector increment is not specified then it’s capacity will be doubled in every increment cycle.
-The capacity of a vector cannot be below the size, it may equal to it.
1) adding elements in a vector
To add the elements to the Vector, we use the add() method.
-add(Object): This method is used to add an element at the end of the Vector.
-add(int index, Object): This method is used to add an element at a specific index in the Vector.
2) Updating Elements
To update an element in a Vector, use the set() method.
It takes the index and the new element to replace the existing one at that position.
3) Removing Elements
To remove an element from a Vector, we can use the remove() method.
They are:
-remove(Object): This method is used to remove an object from the Vector.
If there are multiple such objects, then the first occurrence of the object is removed.
-remove(int index): This method takes an integer value which simply removes the element present at that specific index in the Vector.
After removing the element, all the elements are moved to the left to fill the space and the indices of the objects are updated.
4) Iterating the Vector
The most famous ways are by using the basic for loop in combination with a get() method to get the element at a specific index and the advanced for a loop.
    Vector vs ArrayList in Java
ArrayList and Vectors both implement the List interface,
and both use (dynamically resizable) arrays for their internal data structure.
      ArrayList	                        Vector
1) ArrayList is not synchronized.       Vector is synchronized.
2) ArrayList increments 50% of the      Vector increments 100% means doubles the array size
    current array size if the number    if the total number of elements exceeds its capacity.
 of elements exceeds its capacity.
3)ArrayList is not a legacy class.      Vector is a legacy class.
4)ArrayList is fast because             Vector is slow because it is synchronized.
it is non-synchronized.
5)ArrayList uses the Iterator           A Vector can use the Iterator interface or
interface to traverse the elements      Enumeration interface to traverse the elements.
6)ArrayList performance is high         Vector performance is low.
7)Multiple threads is allowed           only one threads are allowed.
    Significant Differences between ArrayList and Vector
Synchronization:
Vector is synchronized, which means only one thread at a time can access the code.
while ArrayList is not synchronized, which means multiple threads can work on ArrayList at the same time.
    Disadvantages of using Vector in Java
1)The synchronization in Vector can lead to slower performance compared to other collection classes, such as ArrayList.
2)If you don't need the synchronization features of Vector, using it will add unnecessary overhead to your code.
    Methods in Vector Class
1)add(E e): Appends the specified element to the end of this Vector.
2)add(int index, E element): Inserts the specified element at the specified position in this Vector.
3)addAll(Collection<?extends E> c): Appends all elements from the given collection to the end of this Vector.
4)addAll(int index,Collection<? extends E> c): Insert all of the elements in the specified Collection into this
Vector at the specified position.
5)addElement(E obj): Adds the specified element to the end, increasing size by one.
6)capacity(): Returns the current capacity of this vector.
7)clear(): Removes all of the elements from this Vector.
8)clone(): Returns a clone of this vector.
9)contains(Object o): Returns true if this vector contains the specified element.
10)containsAll(Collection<?> c): Returns true if this Vector contains all of the elements in the specified Collection.
11)copyInto(Object[] anArray): Copies the components of this vector into the specified array.
12)elementAt(int index): Returns the component at the specified index.
13)elements(): Returns an enumeration of the components of this vector.
14)ensureCapacity(int minCapacity): Increases capacity to ensure it can hold at least the specified number of elements.
15)equals(Object o): Compares the specified Object with this Vector for equality.
16)firstElement(): Returns the first component (the item at index 0) of this vector.
17)forEach(Consumer<?super E> action): Performs the given action for each element of the Iterable until all elements
have been processed or the action throws an exception.
18)get(int index): Returns the element at the specified position in this Vector.
19)hashCode(): Returns the hash code value for this Vector.
20)indexOf(Object o): Returns index of the first occurrence of the element or -1 if not found.
21)indexOf(Object o, int index): Returns index of the first occurrence starting from the given index.
22)insertElementAt(E obj, int index): Inserts the specified object as a component in this vector at the specified index.
23)isEmpty(): Tests if this vector has no components.
24)iterator(): Returns an iterator over the elements in this list in a proper sequence.
25)lastElement(): Returns the last component of the vector.
26)lastIndexOf(Object o): Returns the index of the last occurrence of the element or -1 if not found.
27)lastIndexOf(Object o, int index): Returns index of the last occurrence before the given index.
28)listIterator(): Returns a list iterator over the elements in this list (in proper sequence).
29)listIterator(int index): Returns a list iterator over the elements in this list (in proper sequence),
starting at the specified position in the list.
30)remove(int index): Removes the element at the specified position in this Vector.
31)remove(Object o): Removes the first occurrence of the specified element.
32)removeAll(Collection<?> c): Removes from this Vector all of its elements contained in the specified Collection.
33)removeAllElements(): Removes all components from this vector and sets its size to zero.
34)removeElement(Object obj): Removes the first (lowest-indexed) occurrence of the argument from this vector.
35)removeElementAt(int index): Deletes the component at the specified index.
36)removeIf(Predicate<? super E> filter): Removes all of the elements of this collection that satisfy the given predicate.
37)removeRange(int fromIndex,int toIndex): Removes from this list all of the elements whose index is between fromIndex,
inclusive and toIndex, exclusive.
38)replaceAll(UnaryOperator<E> operator): Replaces each element of this list with the result of applying the operator to that element.
39)retainAll(Collection<?> c): Retains only the elements in this Vector contained in the specified Collection.
40)set(int index, E element): Replaces the element at the specified position in this Vector with the specified element.
41)setElementAt(E obj, int index): Sets the component at the specified index of this vector to be the specified object.
42)setSize(int newSize): Sets the size of this vector.
43)size(): Returns the number of components in this vector.
44)sort(Comparator<? super E> c): Sorts this list according to the order induced by the specified Comparator.
45)spliterator(): Creates a late-binding and fail-fast Spliterator over the elements in this list.
46)subList(int fromIndex, int toIndex): Returns a view of the portion of this List between fromIndex,
inclusive and toIndex, exclusive.
47)toArray(): Returns an array containing all of the elements in this Vector in the correct order.
48)toArray(T[] a): Returns an array containing all the elements.
49)toString(): Returns a string representation of this Vector, containing the String representation of each element.
50)trimToSize(): Trims the capacity of this vector to be the vector's current size.
     Vector provides us with dynamic arrays in Java.
This is a legacy class. It is a thread-safe class.
This is not recommended being used in a single-threaded environment as it might cause extra overheads.
However, to overcome this in Vectors place one can readily use ArrayList.
A single-threaded environment is one where a program can only execute one task at a time.
    How to check if a vector is empty
The Java.util.Vector.isEmpty() method in Java is used to check and verify if a Vector is empty or not.
It returns True if the Vector is empty else it returns False.
    How to Iterate the Vector Elements in the Reverse Order in Java
We will be using two methods:
1)Using For Loop
2)Using ListIterator
The ListIterator method takes the starting index from where traversal has to begin and returns the ListIterator.
ListIterator has methods to traversal forward as well as backward.
We will pass starting index as equal to the size of the array, and then we will use the hasPrevious() method of ListIterator,
in which we will print the backward element to the current index if exists.
    How to copy one java Vector to Another Vector in java
Previously vector was a part of legacy classes but now it is part of Collections.
It also implements a List interface, so we can use any method of list interface on vectors also.
    Ways To copy elements of one vector to another:
1)Passing in the constructor
-In this approach, we will simply pass the one Vector into the other Vector's constructor.
-By using this approach if we change in first vector values then it will not change the values of the second vector.
-This is the easiest way of duplicating the vector values.This is the easiest way of duplicating the vector values.
2)Adding one by one using add() method
-In this approach, we will iterate over each element of  Vector and add that element in the second Vector.
-Here if you change the first Vector element then it will not change the elements of the second Vector.
-It is not the best approach but it's a simple iteration process.
    How to Find the Minimum or Maximum Element from the Vector in Java?
Methods:
1)Using Collection.min() and Collection.max() methods.
Collections package offers a static method of finding the minimum and maximum in a collection.
These methods are Collections.max() and Collections.min().
-Collections.max() finds the maximum element
-Collections.min() finds the minimum element in a collection.
2)Using Iterating over vector elements setting min-max.
-Take a variable say minNumber, and initialized to the maximum value later on to compare and update.
-Take a variable say maxNumber, and initialized to minimum value later on to compare an update.
-Iterate through Vector and compare each element with the above two-variable -
 minNumber
 maxNumber
 -If the number is less than minNumber, update the value of minNumber.
 -If the number is greater than maxNumber, update the value of maxNumber.

    Stack
This class is based on the basic principle of last-in-first-out.
This is a legacy class.
This inherits from a Vector class.
It is also a thread-safe class.
This is not recommended being used in a single-threaded environment as it might cause extra overheads.
However, to overcome this in Vectors place one can readily use ArrayDeque.
-ArrayDeque: ArrayDeque is a resizable array implementation of the Deque interface.
which stands for double-ended queue.
-It allows elements to be added or removed from both ends efficiently.
-It can be used as a stack (LIFO) or a queue (FIFO).
-Operations like addFirst(), addLast(), removeFirst(), removeLast() are all done in constant time O(1).
-The ArrayDeque class implements these two interfaces Queue interface and Deque interface. s
upport concurrent access by multiple threads.